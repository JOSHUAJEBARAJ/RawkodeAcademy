// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ContourConfiguration is the schema for a Contour instance.
 *
 * @schema ContourConfiguration
 */
export class ContourConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ContourConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'projectcontour.io/v1alpha1',
    kind: 'ContourConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "ContourConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ContourConfigurationProps): any {
    return {
      ...ContourConfiguration.GVK,
      ...toJson_ContourConfigurationProps(props),
    };
  }

  /**
   * Defines a "ContourConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ContourConfigurationProps) {
    super(scope, id, {
      ...ContourConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ContourConfiguration.GVK,
      ...toJson_ContourConfigurationProps(resolved),
    };
  }
}

/**
 * ContourConfiguration is the schema for a Contour instance.
 *
 * @schema ContourConfiguration
 */
export interface ContourConfigurationProps {
  /**
   * @schema ContourConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ContourConfigurationSpec represents a configuration of a Contour controller. It contains most of all the options that can be customized, the other remaining options being command line flags.
   *
   * @schema ContourConfiguration#spec
   */
  readonly spec: ContourConfigurationSpec;

}

/**
 * Converts an object of type 'ContourConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationProps(obj: ContourConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ContourConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContourConfigurationSpec represents a configuration of a Contour controller. It contains most of all the options that can be customized, the other remaining options being command line flags.
 *
 * @schema ContourConfigurationSpec
 */
export interface ContourConfigurationSpec {
  /**
   * Debug contains parameters to enable debug logging and debug interfaces inside Contour.
   *
   * @schema ContourConfigurationSpec#debug
   */
  readonly debug?: ContourConfigurationSpecDebug;

  /**
   * EnableExternalNameService allows processing of ExternalNameServices
   * Contour's default is false for security reasons.
   *
   * @schema ContourConfigurationSpec#enableExternalNameService
   */
  readonly enableExternalNameService?: boolean;

  /**
   * Envoy contains parameters for Envoy as well as how to optionally configure a managed Envoy fleet.
   *
   * @schema ContourConfigurationSpec#envoy
   */
  readonly envoy?: ContourConfigurationSpecEnvoy;

  /**
   * Gateway contains parameters for the gateway-api Gateway that Contour is configured to serve traffic.
   *
   * @schema ContourConfigurationSpec#gateway
   */
  readonly gateway?: ContourConfigurationSpecGateway;

  /**
   * Health defines the endpoints Contour uses to serve health checks.
   * Contour's default is { address: "0.0.0.0", port: 8000 }.
   *
   * @schema ContourConfigurationSpec#health
   */
  readonly health?: ContourConfigurationSpecHealth;

  /**
   * HTTPProxy defines parameters on HTTPProxy.
   *
   * @schema ContourConfigurationSpec#httpproxy
   */
  readonly httpproxy?: ContourConfigurationSpecHttpproxy;

  /**
   * Ingress contains parameters for ingress options.
   *
   * @schema ContourConfigurationSpec#ingress
   */
  readonly ingress?: ContourConfigurationSpecIngress;

  /**
   * Metrics defines the endpoint Contour uses to serve metrics.
   * Contour's default is { address: "0.0.0.0", port: 8000 }.
   *
   * @schema ContourConfigurationSpec#metrics
   */
  readonly metrics?: ContourConfigurationSpecMetrics;

  /**
   * Policy specifies default policy applied if not overridden by the user
   *
   * @schema ContourConfigurationSpec#policy
   */
  readonly policy?: ContourConfigurationSpecPolicy;

  /**
   * RateLimitService optionally holds properties of the Rate Limit Service to be used for global rate limiting.
   *
   * @schema ContourConfigurationSpec#rateLimitService
   */
  readonly rateLimitService?: ContourConfigurationSpecRateLimitService;

  /**
   * XDSServer contains parameters for the xDS server.
   *
   * @schema ContourConfigurationSpec#xdsServer
   */
  readonly xdsServer?: ContourConfigurationSpecXdsServer;

}

/**
 * Converts an object of type 'ContourConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpec(obj: ContourConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'debug': toJson_ContourConfigurationSpecDebug(obj.debug),
    'enableExternalNameService': obj.enableExternalNameService,
    'envoy': toJson_ContourConfigurationSpecEnvoy(obj.envoy),
    'gateway': toJson_ContourConfigurationSpecGateway(obj.gateway),
    'health': toJson_ContourConfigurationSpecHealth(obj.health),
    'httpproxy': toJson_ContourConfigurationSpecHttpproxy(obj.httpproxy),
    'ingress': toJson_ContourConfigurationSpecIngress(obj.ingress),
    'metrics': toJson_ContourConfigurationSpecMetrics(obj.metrics),
    'policy': toJson_ContourConfigurationSpecPolicy(obj.policy),
    'rateLimitService': toJson_ContourConfigurationSpecRateLimitService(obj.rateLimitService),
    'xdsServer': toJson_ContourConfigurationSpecXdsServer(obj.xdsServer),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Debug contains parameters to enable debug logging and debug interfaces inside Contour.
 *
 * @schema ContourConfigurationSpecDebug
 */
export interface ContourConfigurationSpecDebug {
  /**
   * Defines the Contour debug address interface.
   * Contour's default is "127.0.0.1".
   *
   * @schema ContourConfigurationSpecDebug#address
   */
  readonly address?: string;

  /**
   * Defines the Contour debug address port.
   * Contour's default is 6060.
   *
   * @schema ContourConfigurationSpecDebug#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'ContourConfigurationSpecDebug' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecDebug(obj: ContourConfigurationSpecDebug | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Envoy contains parameters for Envoy as well as how to optionally configure a managed Envoy fleet.
 *
 * @schema ContourConfigurationSpecEnvoy
 */
export interface ContourConfigurationSpecEnvoy {
  /**
   * ClientCertificate defines the namespace/name of the Kubernetes secret containing the client certificate and private key to be used when establishing TLS connection to upstream cluster.
   *
   * @schema ContourConfigurationSpecEnvoy#clientCertificate
   */
  readonly clientCertificate?: ContourConfigurationSpecEnvoyClientCertificate;

  /**
   * Cluster holds various configurable Envoy cluster values that can be set in the config file.
   *
   * @schema ContourConfigurationSpecEnvoy#cluster
   */
  readonly cluster?: ContourConfigurationSpecEnvoyCluster;

  /**
   * DefaultHTTPVersions defines the default set of HTTPS versions the proxy should accept. HTTP versions are strings of the form "HTTP/xx". Supported versions are "HTTP/1.1" and "HTTP/2".
   * Values: `HTTP/1.1`, `HTTP/2` (default: both).
   * Other values will produce an error.
   *
   * @schema ContourConfigurationSpecEnvoy#defaultHTTPVersions
   */
  readonly defaultHttpVersions?: string[];

  /**
   * Health defines the endpoint Envoy uses to serve health checks.
   * Contour's default is { address: "0.0.0.0", port: 8002 }.
   *
   * @schema ContourConfigurationSpecEnvoy#health
   */
  readonly health?: ContourConfigurationSpecEnvoyHealth;

  /**
   * Defines the HTTP Listener for Envoy.
   * Contour's default is { address: "0.0.0.0", port: 8080, accessLog: "/dev/stdout" }.
   *
   * @schema ContourConfigurationSpecEnvoy#http
   */
  readonly http?: ContourConfigurationSpecEnvoyHttp;

  /**
   * Defines the HTTPS Listener for Envoy.
   * Contour's default is { address: "0.0.0.0", port: 8443, accessLog: "/dev/stdout" }.
   *
   * @schema ContourConfigurationSpecEnvoy#https
   */
  readonly https?: ContourConfigurationSpecEnvoyHttps;

  /**
   * Listener hold various configurable Envoy listener values.
   *
   * @schema ContourConfigurationSpecEnvoy#listener
   */
  readonly listener?: ContourConfigurationSpecEnvoyListener;

  /**
   * Logging defines how Envoy's logs can be configured.
   *
   * @schema ContourConfigurationSpecEnvoy#logging
   */
  readonly logging?: ContourConfigurationSpecEnvoyLogging;

  /**
   * Metrics defines the endpoint Envoy uses to serve metrics.
   * Contour's default is { address: "0.0.0.0", port: 8002 }.
   *
   * @schema ContourConfigurationSpecEnvoy#metrics
   */
  readonly metrics?: ContourConfigurationSpecEnvoyMetrics;

  /**
   * Network holds various configurable Envoy network values.
   *
   * @schema ContourConfigurationSpecEnvoy#network
   */
  readonly network?: ContourConfigurationSpecEnvoyNetwork;

  /**
   * Service holds Envoy service parameters for setting Ingress status.
   * Contour's default is { namespace: "projectcontour", name: "envoy" }.
   *
   * @schema ContourConfigurationSpecEnvoy#service
   */
  readonly service?: ContourConfigurationSpecEnvoyService;

  /**
   * Timeouts holds various configurable timeouts that can be set in the config file.
   *
   * @schema ContourConfigurationSpecEnvoy#timeouts
   */
  readonly timeouts?: ContourConfigurationSpecEnvoyTimeouts;

}

/**
 * Converts an object of type 'ContourConfigurationSpecEnvoy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecEnvoy(obj: ContourConfigurationSpecEnvoy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCertificate': toJson_ContourConfigurationSpecEnvoyClientCertificate(obj.clientCertificate),
    'cluster': toJson_ContourConfigurationSpecEnvoyCluster(obj.cluster),
    'defaultHTTPVersions': obj.defaultHttpVersions?.map(y => y),
    'health': toJson_ContourConfigurationSpecEnvoyHealth(obj.health),
    'http': toJson_ContourConfigurationSpecEnvoyHttp(obj.http),
    'https': toJson_ContourConfigurationSpecEnvoyHttps(obj.https),
    'listener': toJson_ContourConfigurationSpecEnvoyListener(obj.listener),
    'logging': toJson_ContourConfigurationSpecEnvoyLogging(obj.logging),
    'metrics': toJson_ContourConfigurationSpecEnvoyMetrics(obj.metrics),
    'network': toJson_ContourConfigurationSpecEnvoyNetwork(obj.network),
    'service': toJson_ContourConfigurationSpecEnvoyService(obj.service),
    'timeouts': toJson_ContourConfigurationSpecEnvoyTimeouts(obj.timeouts),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Gateway contains parameters for the gateway-api Gateway that Contour is configured to serve traffic.
 *
 * @schema ContourConfigurationSpecGateway
 */
export interface ContourConfigurationSpecGateway {
  /**
   * ControllerName is used to determine whether Contour should reconcile a GatewayClass. The string takes the form of "projectcontour.io/<namespace>/contour". If unset, the gatewayclass controller will not be started. Exactly one of ControllerName or GatewayRef must be set.
   *
   * @schema ContourConfigurationSpecGateway#controllerName
   */
  readonly controllerName?: string;

  /**
   * GatewayRef defines a specific Gateway that this Contour instance corresponds to. If set, Contour will reconcile only this gateway, and will not reconcile any gateway classes. Exactly one of ControllerName or GatewayRef must be set.
   *
   * @schema ContourConfigurationSpecGateway#gatewayRef
   */
  readonly gatewayRef?: ContourConfigurationSpecGatewayGatewayRef;

}

/**
 * Converts an object of type 'ContourConfigurationSpecGateway' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecGateway(obj: ContourConfigurationSpecGateway | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'controllerName': obj.controllerName,
    'gatewayRef': toJson_ContourConfigurationSpecGatewayGatewayRef(obj.gatewayRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Health defines the endpoints Contour uses to serve health checks.
 * Contour's default is { address: "0.0.0.0", port: 8000 }.
 *
 * @schema ContourConfigurationSpecHealth
 */
export interface ContourConfigurationSpecHealth {
  /**
   * Defines the health address interface.
   *
   * @schema ContourConfigurationSpecHealth#address
   */
  readonly address?: string;

  /**
   * Defines the health port.
   *
   * @schema ContourConfigurationSpecHealth#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'ContourConfigurationSpecHealth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecHealth(obj: ContourConfigurationSpecHealth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPProxy defines parameters on HTTPProxy.
 *
 * @schema ContourConfigurationSpecHttpproxy
 */
export interface ContourConfigurationSpecHttpproxy {
  /**
   * DisablePermitInsecure disables the use of the permitInsecure field in HTTPProxy.
   * Contour's default is false.
   *
   * @schema ContourConfigurationSpecHttpproxy#disablePermitInsecure
   */
  readonly disablePermitInsecure?: boolean;

  /**
   * FallbackCertificate defines the namespace/name of the Kubernetes secret to use as fallback when a non-SNI request is received.
   *
   * @schema ContourConfigurationSpecHttpproxy#fallbackCertificate
   */
  readonly fallbackCertificate?: ContourConfigurationSpecHttpproxyFallbackCertificate;

  /**
   * Restrict Contour to searching these namespaces for root ingress routes.
   *
   * @schema ContourConfigurationSpecHttpproxy#rootNamespaces
   */
  readonly rootNamespaces?: string[];

}

/**
 * Converts an object of type 'ContourConfigurationSpecHttpproxy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecHttpproxy(obj: ContourConfigurationSpecHttpproxy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disablePermitInsecure': obj.disablePermitInsecure,
    'fallbackCertificate': toJson_ContourConfigurationSpecHttpproxyFallbackCertificate(obj.fallbackCertificate),
    'rootNamespaces': obj.rootNamespaces?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ingress contains parameters for ingress options.
 *
 * @schema ContourConfigurationSpecIngress
 */
export interface ContourConfigurationSpecIngress {
  /**
   * Ingress Class Names Contour should use.
   *
   * @schema ContourConfigurationSpecIngress#classNames
   */
  readonly classNames?: string[];

  /**
   * Address to set in Ingress object status.
   *
   * @schema ContourConfigurationSpecIngress#statusAddress
   */
  readonly statusAddress?: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecIngress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecIngress(obj: ContourConfigurationSpecIngress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'classNames': obj.classNames?.map(y => y),
    'statusAddress': obj.statusAddress,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metrics defines the endpoint Contour uses to serve metrics.
 * Contour's default is { address: "0.0.0.0", port: 8000 }.
 *
 * @schema ContourConfigurationSpecMetrics
 */
export interface ContourConfigurationSpecMetrics {
  /**
   * Defines the metrics address interface.
   *
   * @schema ContourConfigurationSpecMetrics#address
   */
  readonly address?: string;

  /**
   * Defines the metrics port.
   *
   * @schema ContourConfigurationSpecMetrics#port
   */
  readonly port?: number;

  /**
   * TLS holds TLS file config details. Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.
   *
   * @schema ContourConfigurationSpecMetrics#tls
   */
  readonly tls?: ContourConfigurationSpecMetricsTls;

}

/**
 * Converts an object of type 'ContourConfigurationSpecMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecMetrics(obj: ContourConfigurationSpecMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'port': obj.port,
    'tls': toJson_ContourConfigurationSpecMetricsTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policy specifies default policy applied if not overridden by the user
 *
 * @schema ContourConfigurationSpecPolicy
 */
export interface ContourConfigurationSpecPolicy {
  /**
   * ApplyToIngress determines if the Policies will apply to ingress objects
   * Contour's default is false.
   *
   * @schema ContourConfigurationSpecPolicy#applyToIngress
   */
  readonly applyToIngress?: boolean;

  /**
   * RequestHeadersPolicy defines the request headers set/removed on all routes
   *
   * @schema ContourConfigurationSpecPolicy#requestHeaders
   */
  readonly requestHeaders?: ContourConfigurationSpecPolicyRequestHeaders;

  /**
   * ResponseHeadersPolicy defines the response headers set/removed on all routes
   *
   * @schema ContourConfigurationSpecPolicy#responseHeaders
   */
  readonly responseHeaders?: ContourConfigurationSpecPolicyResponseHeaders;

}

/**
 * Converts an object of type 'ContourConfigurationSpecPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecPolicy(obj: ContourConfigurationSpecPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyToIngress': obj.applyToIngress,
    'requestHeaders': toJson_ContourConfigurationSpecPolicyRequestHeaders(obj.requestHeaders),
    'responseHeaders': toJson_ContourConfigurationSpecPolicyResponseHeaders(obj.responseHeaders),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RateLimitService optionally holds properties of the Rate Limit Service to be used for global rate limiting.
 *
 * @schema ContourConfigurationSpecRateLimitService
 */
export interface ContourConfigurationSpecRateLimitService {
  /**
   * Domain is passed to the Rate Limit Service.
   *
   * @schema ContourConfigurationSpecRateLimitService#domain
   */
  readonly domain?: string;

  /**
   * EnableXRateLimitHeaders defines whether to include the X-RateLimit headers X-RateLimit-Limit, X-RateLimit-Remaining, and X-RateLimit-Reset (as defined by the IETF Internet-Draft linked below), on responses to clients when the Rate Limit Service is consulted for a request.
   * ref. https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html
   *
   * @schema ContourConfigurationSpecRateLimitService#enableXRateLimitHeaders
   */
  readonly enableXRateLimitHeaders?: boolean;

  /**
   * ExtensionService identifies the extension service defining the RLS.
   *
   * @schema ContourConfigurationSpecRateLimitService#extensionService
   */
  readonly extensionService: ContourConfigurationSpecRateLimitServiceExtensionService;

  /**
   * FailOpen defines whether to allow requests to proceed when the Rate Limit Service fails to respond with a valid rate limit decision within the timeout defined on the extension service.
   *
   * @schema ContourConfigurationSpecRateLimitService#failOpen
   */
  readonly failOpen?: boolean;

}

/**
 * Converts an object of type 'ContourConfigurationSpecRateLimitService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecRateLimitService(obj: ContourConfigurationSpecRateLimitService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domain': obj.domain,
    'enableXRateLimitHeaders': obj.enableXRateLimitHeaders,
    'extensionService': toJson_ContourConfigurationSpecRateLimitServiceExtensionService(obj.extensionService),
    'failOpen': obj.failOpen,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * XDSServer contains parameters for the xDS server.
 *
 * @schema ContourConfigurationSpecXdsServer
 */
export interface ContourConfigurationSpecXdsServer {
  /**
   * Defines the xDS gRPC API address which Contour will serve.
   * Contour's default is "0.0.0.0".
   *
   * @schema ContourConfigurationSpecXdsServer#address
   */
  readonly address?: string;

  /**
   * Defines the xDS gRPC API port which Contour will serve.
   * Contour's default is 8001.
   *
   * @schema ContourConfigurationSpecXdsServer#port
   */
  readonly port?: number;

  /**
   * TLS holds TLS file config details.
   * Contour's default is { caFile: "/certs/ca.crt", certFile: "/certs/tls.cert", keyFile: "/certs/tls.key", insecure: false }.
   *
   * @schema ContourConfigurationSpecXdsServer#tls
   */
  readonly tls?: ContourConfigurationSpecXdsServerTls;

  /**
   * Defines the XDSServer to use for `contour serve`.
   * Values: `contour` (default), `envoy`.
   * Other values will produce an error.
   *
   * @schema ContourConfigurationSpecXdsServer#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecXdsServer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecXdsServer(obj: ContourConfigurationSpecXdsServer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'port': obj.port,
    'tls': toJson_ContourConfigurationSpecXdsServerTls(obj.tls),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClientCertificate defines the namespace/name of the Kubernetes secret containing the client certificate and private key to be used when establishing TLS connection to upstream cluster.
 *
 * @schema ContourConfigurationSpecEnvoyClientCertificate
 */
export interface ContourConfigurationSpecEnvoyClientCertificate {
  /**
   * @schema ContourConfigurationSpecEnvoyClientCertificate#name
   */
  readonly name: string;

  /**
   * @schema ContourConfigurationSpecEnvoyClientCertificate#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecEnvoyClientCertificate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecEnvoyClientCertificate(obj: ContourConfigurationSpecEnvoyClientCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cluster holds various configurable Envoy cluster values that can be set in the config file.
 *
 * @schema ContourConfigurationSpecEnvoyCluster
 */
export interface ContourConfigurationSpecEnvoyCluster {
  /**
   * DNSLookupFamily defines how external names are looked up When configured as V4, the DNS resolver will only perform a lookup for addresses in the IPv4 family. If V6 is configured, the DNS resolver will only perform a lookup for addresses in the IPv6 family. If AUTO is configured, the DNS resolver will first perform a lookup for addresses in the IPv6 family and fallback to a lookup for addresses in the IPv4 family. Note: This only applies to externalName clusters.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-enum-config-cluster-v3-cluster-dnslookupfamily for more information.
   * Values: `auto` (default), `v4`, `v6`.
   * Other values will produce an error.
   *
   * @schema ContourConfigurationSpecEnvoyCluster#dnsLookupFamily
   */
  readonly dnsLookupFamily?: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecEnvoyCluster' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecEnvoyCluster(obj: ContourConfigurationSpecEnvoyCluster | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsLookupFamily': obj.dnsLookupFamily,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Health defines the endpoint Envoy uses to serve health checks.
 * Contour's default is { address: "0.0.0.0", port: 8002 }.
 *
 * @schema ContourConfigurationSpecEnvoyHealth
 */
export interface ContourConfigurationSpecEnvoyHealth {
  /**
   * Defines the health address interface.
   *
   * @schema ContourConfigurationSpecEnvoyHealth#address
   */
  readonly address?: string;

  /**
   * Defines the health port.
   *
   * @schema ContourConfigurationSpecEnvoyHealth#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'ContourConfigurationSpecEnvoyHealth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecEnvoyHealth(obj: ContourConfigurationSpecEnvoyHealth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the HTTP Listener for Envoy.
 * Contour's default is { address: "0.0.0.0", port: 8080, accessLog: "/dev/stdout" }.
 *
 * @schema ContourConfigurationSpecEnvoyHttp
 */
export interface ContourConfigurationSpecEnvoyHttp {
  /**
   * AccessLog defines where Envoy logs are outputted for this listener.
   *
   * @schema ContourConfigurationSpecEnvoyHttp#accessLog
   */
  readonly accessLog?: string;

  /**
   * Defines an Envoy Listener Address.
   *
   * @schema ContourConfigurationSpecEnvoyHttp#address
   */
  readonly address?: string;

  /**
   * Defines an Envoy listener Port.
   *
   * @schema ContourConfigurationSpecEnvoyHttp#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'ContourConfigurationSpecEnvoyHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecEnvoyHttp(obj: ContourConfigurationSpecEnvoyHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessLog': obj.accessLog,
    'address': obj.address,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the HTTPS Listener for Envoy.
 * Contour's default is { address: "0.0.0.0", port: 8443, accessLog: "/dev/stdout" }.
 *
 * @schema ContourConfigurationSpecEnvoyHttps
 */
export interface ContourConfigurationSpecEnvoyHttps {
  /**
   * AccessLog defines where Envoy logs are outputted for this listener.
   *
   * @schema ContourConfigurationSpecEnvoyHttps#accessLog
   */
  readonly accessLog?: string;

  /**
   * Defines an Envoy Listener Address.
   *
   * @schema ContourConfigurationSpecEnvoyHttps#address
   */
  readonly address?: string;

  /**
   * Defines an Envoy listener Port.
   *
   * @schema ContourConfigurationSpecEnvoyHttps#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'ContourConfigurationSpecEnvoyHttps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecEnvoyHttps(obj: ContourConfigurationSpecEnvoyHttps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessLog': obj.accessLog,
    'address': obj.address,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Listener hold various configurable Envoy listener values.
 *
 * @schema ContourConfigurationSpecEnvoyListener
 */
export interface ContourConfigurationSpecEnvoyListener {
  /**
   * ConnectionBalancer. If the value is exact, the listener will use the exact connection balancer See https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/listener.proto#envoy-api-msg-listener-connectionbalanceconfig for more information.
   * Values: (empty string): use the default ConnectionBalancer, `exact`: use the Exact ConnectionBalancer.
   * Other values will produce an error.
   *
   * @schema ContourConfigurationSpecEnvoyListener#connectionBalancer
   */
  readonly connectionBalancer?: string;

  /**
   * DisableAllowChunkedLength disables the RFC-compliant Envoy behavior to strip the "Content-Length" header if "Transfer-Encoding: chunked" is also set. This is an emergency off-switch to revert back to Envoy's default behavior in case of failures. Please file an issue if failures are encountered. See: https://github.com/projectcontour/contour/issues/3221
   * Contour's default is false.
   *
   * @schema ContourConfigurationSpecEnvoyListener#disableAllowChunkedLength
   */
  readonly disableAllowChunkedLength?: boolean;

  /**
   * DisableMergeSlashes disables Envoy's non-standard merge_slashes path transformation option which strips duplicate slashes from request URL paths.
   * Contour's default is false.
   *
   * @schema ContourConfigurationSpecEnvoyListener#disableMergeSlashes
   */
  readonly disableMergeSlashes?: boolean;

  /**
   * TLS holds various configurable Envoy TLS listener values.
   *
   * @schema ContourConfigurationSpecEnvoyListener#tls
   */
  readonly tls?: ContourConfigurationSpecEnvoyListenerTls;

  /**
   * Use PROXY protocol for all listeners.
   * Contour's default is false.
   *
   * @schema ContourConfigurationSpecEnvoyListener#useProxyProtocol
   */
  readonly useProxyProtocol?: boolean;

}

/**
 * Converts an object of type 'ContourConfigurationSpecEnvoyListener' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecEnvoyListener(obj: ContourConfigurationSpecEnvoyListener | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionBalancer': obj.connectionBalancer,
    'disableAllowChunkedLength': obj.disableAllowChunkedLength,
    'disableMergeSlashes': obj.disableMergeSlashes,
    'tls': toJson_ContourConfigurationSpecEnvoyListenerTls(obj.tls),
    'useProxyProtocol': obj.useProxyProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Logging defines how Envoy's logs can be configured.
 *
 * @schema ContourConfigurationSpecEnvoyLogging
 */
export interface ContourConfigurationSpecEnvoyLogging {
  /**
   * AccessLogFormat sets the global access log format.
   * Values: `envoy` (default), `json`.
   * Other values will produce an error.
   *
   * @schema ContourConfigurationSpecEnvoyLogging#accessLogFormat
   */
  readonly accessLogFormat?: string;

  /**
   * AccessLogFormatString sets the access log format when format is set to `envoy`. When empty, Envoy's default format is used.
   *
   * @schema ContourConfigurationSpecEnvoyLogging#accessLogFormatString
   */
  readonly accessLogFormatString?: string;

  /**
   * AccessLogJSONFields sets the fields that JSON logging will output when AccessLogFormat is json.
   *
   * @schema ContourConfigurationSpecEnvoyLogging#accessLogJSONFields
   */
  readonly accessLogJsonFields?: string[];

  /**
   * AccessLogLevel sets the verbosity level of the access log.
   * Values: `info` (default, meaning all requests are logged), `error` and `disabled`.
   * Other values will produce an error.
   *
   * @schema ContourConfigurationSpecEnvoyLogging#accessLogLevel
   */
  readonly accessLogLevel?: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecEnvoyLogging' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecEnvoyLogging(obj: ContourConfigurationSpecEnvoyLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessLogFormat': obj.accessLogFormat,
    'accessLogFormatString': obj.accessLogFormatString,
    'accessLogJSONFields': obj.accessLogJsonFields?.map(y => y),
    'accessLogLevel': obj.accessLogLevel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metrics defines the endpoint Envoy uses to serve metrics.
 * Contour's default is { address: "0.0.0.0", port: 8002 }.
 *
 * @schema ContourConfigurationSpecEnvoyMetrics
 */
export interface ContourConfigurationSpecEnvoyMetrics {
  /**
   * Defines the metrics address interface.
   *
   * @schema ContourConfigurationSpecEnvoyMetrics#address
   */
  readonly address?: string;

  /**
   * Defines the metrics port.
   *
   * @schema ContourConfigurationSpecEnvoyMetrics#port
   */
  readonly port?: number;

  /**
   * TLS holds TLS file config details. Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.
   *
   * @schema ContourConfigurationSpecEnvoyMetrics#tls
   */
  readonly tls?: ContourConfigurationSpecEnvoyMetricsTls;

}

/**
 * Converts an object of type 'ContourConfigurationSpecEnvoyMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecEnvoyMetrics(obj: ContourConfigurationSpecEnvoyMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'port': obj.port,
    'tls': toJson_ContourConfigurationSpecEnvoyMetricsTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Network holds various configurable Envoy network values.
 *
 * @schema ContourConfigurationSpecEnvoyNetwork
 */
export interface ContourConfigurationSpecEnvoyNetwork {
  /**
   * Configure the port used to access the Envoy Admin interface. If configured to port "0" then the admin interface is disabled.
   * Contour's default is 9001.
   *
   * @schema ContourConfigurationSpecEnvoyNetwork#adminPort
   */
  readonly adminPort?: number;

  /**
   * XffNumTrustedHops defines the number of additional ingress proxy hops from the right side of the x-forwarded-for HTTP header to trust when determining the origin client’s IP address.
   * See https://www.envoyproxy.io/docs/envoy/v1.17.0/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto?highlight=xff_num_trusted_hops for more information.
   * Contour's default is 0.
   *
   * @schema ContourConfigurationSpecEnvoyNetwork#numTrustedHops
   */
  readonly numTrustedHops?: number;

}

/**
 * Converts an object of type 'ContourConfigurationSpecEnvoyNetwork' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecEnvoyNetwork(obj: ContourConfigurationSpecEnvoyNetwork | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'adminPort': obj.adminPort,
    'numTrustedHops': obj.numTrustedHops,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Service holds Envoy service parameters for setting Ingress status.
 * Contour's default is { namespace: "projectcontour", name: "envoy" }.
 *
 * @schema ContourConfigurationSpecEnvoyService
 */
export interface ContourConfigurationSpecEnvoyService {
  /**
   * @schema ContourConfigurationSpecEnvoyService#name
   */
  readonly name: string;

  /**
   * @schema ContourConfigurationSpecEnvoyService#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecEnvoyService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecEnvoyService(obj: ContourConfigurationSpecEnvoyService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Timeouts holds various configurable timeouts that can be set in the config file.
 *
 * @schema ContourConfigurationSpecEnvoyTimeouts
 */
export interface ContourConfigurationSpecEnvoyTimeouts {
  /**
   * ConnectTimeout defines how long the proxy should wait when establishing connection to upstream service. If not set, a default value of 2 seconds will be used.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#envoy-v3-api-field-config-cluster-v3-cluster-connect-timeout for more information.
   *
   * @schema ContourConfigurationSpecEnvoyTimeouts#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * ConnectionIdleTimeout defines how long the proxy should wait while there are no active requests (for HTTP/1.1) or streams (for HTTP/2) before terminating an HTTP connection. Set to "infinity" to disable the timeout entirely.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-idle-timeout for more information.
   *
   * @schema ContourConfigurationSpecEnvoyTimeouts#connectionIdleTimeout
   */
  readonly connectionIdleTimeout?: string;

  /**
   * ConnectionShutdownGracePeriod defines how long the proxy will wait between sending an initial GOAWAY frame and a second, final GOAWAY frame when terminating an HTTP/2 connection. During this grace period, the proxy will continue to respond to new streams. After the final GOAWAY frame has been sent, the proxy will refuse new streams.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-drain-timeout for more information.
   *
   * @schema ContourConfigurationSpecEnvoyTimeouts#connectionShutdownGracePeriod
   */
  readonly connectionShutdownGracePeriod?: string;

  /**
   * DelayedCloseTimeout defines how long envoy will wait, once connection close processing has been initiated, for the downstream peer to close the connection before Envoy closes the socket associated with the connection.
   * Setting this timeout to 'infinity' will disable it, equivalent to setting it to '0' in Envoy. Leaving it unset will result in the Envoy default value being used.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-delayed-close-timeout for more information.
   *
   * @schema ContourConfigurationSpecEnvoyTimeouts#delayedCloseTimeout
   */
  readonly delayedCloseTimeout?: string;

  /**
   * MaxConnectionDuration defines the maximum period of time after an HTTP connection has been established from the client to the proxy before it is closed by the proxy, regardless of whether there has been activity or not. Omit or set to "infinity" for no max duration.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-max-connection-duration for more information.
   *
   * @schema ContourConfigurationSpecEnvoyTimeouts#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * RequestTimeout sets the client request timeout globally for Contour. Note that this is a timeout for the entire request, not an idle timeout. Omit or set to "infinity" to disable the timeout entirely.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-request-timeout for more information.
   *
   * @schema ContourConfigurationSpecEnvoyTimeouts#requestTimeout
   */
  readonly requestTimeout?: string;

  /**
   * StreamIdleTimeout defines how long the proxy should wait while there is no request activity (for HTTP/1.1) or stream activity (for HTTP/2) before terminating the HTTP request or stream. Set to "infinity" to disable the timeout entirely.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-stream-idle-timeout for more information.
   *
   * @schema ContourConfigurationSpecEnvoyTimeouts#streamIdleTimeout
   */
  readonly streamIdleTimeout?: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecEnvoyTimeouts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecEnvoyTimeouts(obj: ContourConfigurationSpecEnvoyTimeouts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'connectionIdleTimeout': obj.connectionIdleTimeout,
    'connectionShutdownGracePeriod': obj.connectionShutdownGracePeriod,
    'delayedCloseTimeout': obj.delayedCloseTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'requestTimeout': obj.requestTimeout,
    'streamIdleTimeout': obj.streamIdleTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GatewayRef defines a specific Gateway that this Contour instance corresponds to. If set, Contour will reconcile only this gateway, and will not reconcile any gateway classes. Exactly one of ControllerName or GatewayRef must be set.
 *
 * @schema ContourConfigurationSpecGatewayGatewayRef
 */
export interface ContourConfigurationSpecGatewayGatewayRef {
  /**
   * @schema ContourConfigurationSpecGatewayGatewayRef#name
   */
  readonly name: string;

  /**
   * @schema ContourConfigurationSpecGatewayGatewayRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecGatewayGatewayRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecGatewayGatewayRef(obj: ContourConfigurationSpecGatewayGatewayRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FallbackCertificate defines the namespace/name of the Kubernetes secret to use as fallback when a non-SNI request is received.
 *
 * @schema ContourConfigurationSpecHttpproxyFallbackCertificate
 */
export interface ContourConfigurationSpecHttpproxyFallbackCertificate {
  /**
   * @schema ContourConfigurationSpecHttpproxyFallbackCertificate#name
   */
  readonly name: string;

  /**
   * @schema ContourConfigurationSpecHttpproxyFallbackCertificate#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecHttpproxyFallbackCertificate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecHttpproxyFallbackCertificate(obj: ContourConfigurationSpecHttpproxyFallbackCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS holds TLS file config details. Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.
 *
 * @schema ContourConfigurationSpecMetricsTls
 */
export interface ContourConfigurationSpecMetricsTls {
  /**
   * CA filename.
   *
   * @schema ContourConfigurationSpecMetricsTls#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate filename.
   *
   * @schema ContourConfigurationSpecMetricsTls#certFile
   */
  readonly certFile?: string;

  /**
   * Client key filename.
   *
   * @schema ContourConfigurationSpecMetricsTls#keyFile
   */
  readonly keyFile?: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecMetricsTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecMetricsTls(obj: ContourConfigurationSpecMetricsTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caFile': obj.caFile,
    'certFile': obj.certFile,
    'keyFile': obj.keyFile,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RequestHeadersPolicy defines the request headers set/removed on all routes
 *
 * @schema ContourConfigurationSpecPolicyRequestHeaders
 */
export interface ContourConfigurationSpecPolicyRequestHeaders {
  /**
   * @schema ContourConfigurationSpecPolicyRequestHeaders#remove
   */
  readonly remove?: string[];

  /**
   * @schema ContourConfigurationSpecPolicyRequestHeaders#set
   */
  readonly set?: { [key: string]: string };

}

/**
 * Converts an object of type 'ContourConfigurationSpecPolicyRequestHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecPolicyRequestHeaders(obj: ContourConfigurationSpecPolicyRequestHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'remove': obj.remove?.map(y => y),
    'set': ((obj.set) === undefined) ? undefined : (Object.entries(obj.set).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResponseHeadersPolicy defines the response headers set/removed on all routes
 *
 * @schema ContourConfigurationSpecPolicyResponseHeaders
 */
export interface ContourConfigurationSpecPolicyResponseHeaders {
  /**
   * @schema ContourConfigurationSpecPolicyResponseHeaders#remove
   */
  readonly remove?: string[];

  /**
   * @schema ContourConfigurationSpecPolicyResponseHeaders#set
   */
  readonly set?: { [key: string]: string };

}

/**
 * Converts an object of type 'ContourConfigurationSpecPolicyResponseHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecPolicyResponseHeaders(obj: ContourConfigurationSpecPolicyResponseHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'remove': obj.remove?.map(y => y),
    'set': ((obj.set) === undefined) ? undefined : (Object.entries(obj.set).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExtensionService identifies the extension service defining the RLS.
 *
 * @schema ContourConfigurationSpecRateLimitServiceExtensionService
 */
export interface ContourConfigurationSpecRateLimitServiceExtensionService {
  /**
   * @schema ContourConfigurationSpecRateLimitServiceExtensionService#name
   */
  readonly name: string;

  /**
   * @schema ContourConfigurationSpecRateLimitServiceExtensionService#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecRateLimitServiceExtensionService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecRateLimitServiceExtensionService(obj: ContourConfigurationSpecRateLimitServiceExtensionService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS holds TLS file config details.
 * Contour's default is { caFile: "/certs/ca.crt", certFile: "/certs/tls.cert", keyFile: "/certs/tls.key", insecure: false }.
 *
 * @schema ContourConfigurationSpecXdsServerTls
 */
export interface ContourConfigurationSpecXdsServerTls {
  /**
   * CA filename.
   *
   * @schema ContourConfigurationSpecXdsServerTls#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate filename.
   *
   * @schema ContourConfigurationSpecXdsServerTls#certFile
   */
  readonly certFile?: string;

  /**
   * Allow serving the xDS gRPC API without TLS.
   *
   * @schema ContourConfigurationSpecXdsServerTls#insecure
   */
  readonly insecure?: boolean;

  /**
   * Client key filename.
   *
   * @schema ContourConfigurationSpecXdsServerTls#keyFile
   */
  readonly keyFile?: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecXdsServerTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecXdsServerTls(obj: ContourConfigurationSpecXdsServerTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caFile': obj.caFile,
    'certFile': obj.certFile,
    'insecure': obj.insecure,
    'keyFile': obj.keyFile,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS holds various configurable Envoy TLS listener values.
 *
 * @schema ContourConfigurationSpecEnvoyListenerTls
 */
export interface ContourConfigurationSpecEnvoyListenerTls {
  /**
   * CipherSuites defines the TLS ciphers to be supported by Envoy TLS listeners when negotiating TLS 1.2. Ciphers are validated against the set that Envoy supports by default. This parameter should only be used by advanced users. Note that these will be ignored when TLS 1.3 is in use.
   * This field is optional; when it is undefined, a Contour-managed ciphersuite list will be used, which may be updated to keep it secure.
   * Contour's default list is:   - "[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]"   - "[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]"   - "ECDHE-ECDSA-AES256-GCM-SHA384"   - "ECDHE-RSA-AES256-GCM-SHA384"
   * Ciphers provided are validated against the following list:   - "[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]"   - "[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]"   - "ECDHE-ECDSA-AES128-GCM-SHA256"   - "ECDHE-RSA-AES128-GCM-SHA256"   - "ECDHE-ECDSA-AES128-SHA"   - "ECDHE-RSA-AES128-SHA"   - "AES128-GCM-SHA256"   - "AES128-SHA"   - "ECDHE-ECDSA-AES256-GCM-SHA384"   - "ECDHE-RSA-AES256-GCM-SHA384"   - "ECDHE-ECDSA-AES256-SHA"   - "ECDHE-RSA-AES256-SHA"   - "AES256-GCM-SHA384"   - "AES256-SHA"
   * Contour recommends leaving this undefined unless you are sure you must.
   * See: https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/transport_sockets/tls/v3/common.proto#extensions-transport-sockets-tls-v3-tlsparameters Note: This list is a superset of what is valid for stock Envoy builds and those using BoringSSL FIPS.
   *
   * @schema ContourConfigurationSpecEnvoyListenerTls#cipherSuites
   */
  readonly cipherSuites?: string[];

  /**
   * MinimumProtocolVersion is the minimum TLS version this vhost should negotiate.
   * Values: `1.2` (default), `1.3`.
   * Other values will produce an error.
   *
   * @schema ContourConfigurationSpecEnvoyListenerTls#minimumProtocolVersion
   */
  readonly minimumProtocolVersion?: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecEnvoyListenerTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecEnvoyListenerTls(obj: ContourConfigurationSpecEnvoyListenerTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cipherSuites': obj.cipherSuites?.map(y => y),
    'minimumProtocolVersion': obj.minimumProtocolVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS holds TLS file config details. Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.
 *
 * @schema ContourConfigurationSpecEnvoyMetricsTls
 */
export interface ContourConfigurationSpecEnvoyMetricsTls {
  /**
   * CA filename.
   *
   * @schema ContourConfigurationSpecEnvoyMetricsTls#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate filename.
   *
   * @schema ContourConfigurationSpecEnvoyMetricsTls#certFile
   */
  readonly certFile?: string;

  /**
   * Client key filename.
   *
   * @schema ContourConfigurationSpecEnvoyMetricsTls#keyFile
   */
  readonly keyFile?: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecEnvoyMetricsTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecEnvoyMetricsTls(obj: ContourConfigurationSpecEnvoyMetricsTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caFile': obj.caFile,
    'certFile': obj.certFile,
    'keyFile': obj.keyFile,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * ContourDeployment is the schema for a Contour Deployment.
 *
 * @schema ContourDeployment
 */
export class ContourDeployment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ContourDeployment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'projectcontour.io/v1alpha1',
    kind: 'ContourDeployment',
  }

  /**
   * Renders a Kubernetes manifest for "ContourDeployment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ContourDeploymentProps = {}): any {
    return {
      ...ContourDeployment.GVK,
      ...toJson_ContourDeploymentProps(props),
    };
  }

  /**
   * Defines a "ContourDeployment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ContourDeploymentProps = {}) {
    super(scope, id, {
      ...ContourDeployment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ContourDeployment.GVK,
      ...toJson_ContourDeploymentProps(resolved),
    };
  }
}

/**
 * ContourDeployment is the schema for a Contour Deployment.
 *
 * @schema ContourDeployment
 */
export interface ContourDeploymentProps {
  /**
   * @schema ContourDeployment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ContourDeploymentSpec specifies options for how a Contour instance should be provisioned.
   *
   * @schema ContourDeployment#spec
   */
  readonly spec?: ContourDeploymentSpec;

}

/**
 * Converts an object of type 'ContourDeploymentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentProps(obj: ContourDeploymentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ContourDeploymentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContourDeploymentSpec specifies options for how a Contour instance should be provisioned.
 *
 * @schema ContourDeploymentSpec
 */
export interface ContourDeploymentSpec {
  /**
   * Contour specifies deployment-time settings for the Contour part of the installation, i.e. the xDS server/control plane and associated resources, including things like replica count for the Deployment, and node placement constraints for the pods.
   *
   * @schema ContourDeploymentSpec#contour
   */
  readonly contour?: ContourDeploymentSpecContour;

  /**
   * Envoy specifies deployment-time settings for the Envoy part of the installation, i.e. the xDS client/data plane and associated resources, including things like the workload type to use (DaemonSet or Deployment), node placement constraints for the pods, and various options for the Envoy service.
   *
   * @schema ContourDeploymentSpec#envoy
   */
  readonly envoy?: ContourDeploymentSpecEnvoy;

  /**
   * RuntimeSettings is a ContourConfiguration spec to be used when provisioning a Contour instance that will influence aspects of the Contour instance's runtime behavior.
   *
   * @schema ContourDeploymentSpec#runtimeSettings
   */
  readonly runtimeSettings?: ContourDeploymentSpecRuntimeSettings;

}

/**
 * Converts an object of type 'ContourDeploymentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpec(obj: ContourDeploymentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contour': toJson_ContourDeploymentSpecContour(obj.contour),
    'envoy': toJson_ContourDeploymentSpecEnvoy(obj.envoy),
    'runtimeSettings': toJson_ContourDeploymentSpecRuntimeSettings(obj.runtimeSettings),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Contour specifies deployment-time settings for the Contour part of the installation, i.e. the xDS server/control plane and associated resources, including things like replica count for the Deployment, and node placement constraints for the pods.
 *
 * @schema ContourDeploymentSpecContour
 */
export interface ContourDeploymentSpecContour {
  /**
   * NodePlacement describes node scheduling configuration of Contour pods.
   *
   * @schema ContourDeploymentSpecContour#nodePlacement
   */
  readonly nodePlacement?: ContourDeploymentSpecContourNodePlacement;

  /**
   * Replicas is the desired number of Contour replicas. If unset, defaults to 2.
   *
   * @schema ContourDeploymentSpecContour#replicas
   */
  readonly replicas?: number;

}

/**
 * Converts an object of type 'ContourDeploymentSpecContour' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecContour(obj: ContourDeploymentSpecContour | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodePlacement': toJson_ContourDeploymentSpecContourNodePlacement(obj.nodePlacement),
    'replicas': obj.replicas,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Envoy specifies deployment-time settings for the Envoy part of the installation, i.e. the xDS client/data plane and associated resources, including things like the workload type to use (DaemonSet or Deployment), node placement constraints for the pods, and various options for the Envoy service.
 *
 * @schema ContourDeploymentSpecEnvoy
 */
export interface ContourDeploymentSpecEnvoy {
  /**
   * NetworkPublishing defines how to expose Envoy to a network.
   *
   * @schema ContourDeploymentSpecEnvoy#networkPublishing
   */
  readonly networkPublishing?: ContourDeploymentSpecEnvoyNetworkPublishing;

  /**
   * NodePlacement describes node scheduling configuration of Envoy pods.
   *
   * @schema ContourDeploymentSpecEnvoy#nodePlacement
   */
  readonly nodePlacement?: ContourDeploymentSpecEnvoyNodePlacement;

  /**
   * Replicas is the desired number of Envoy replicas. If WorkloadType is not "Deployment", this field is ignored. Otherwise, if unset, defaults to 2.
   *
   * @schema ContourDeploymentSpecEnvoy#replicas
   */
  readonly replicas?: number;

  /**
   * WorkloadType is the type of workload to install Envoy as. Choices are DaemonSet and Deployment. If unset, defaults to DaemonSet.
   *
   * @schema ContourDeploymentSpecEnvoy#workloadType
   */
  readonly workloadType?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoy(obj: ContourDeploymentSpecEnvoy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'networkPublishing': toJson_ContourDeploymentSpecEnvoyNetworkPublishing(obj.networkPublishing),
    'nodePlacement': toJson_ContourDeploymentSpecEnvoyNodePlacement(obj.nodePlacement),
    'replicas': obj.replicas,
    'workloadType': obj.workloadType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RuntimeSettings is a ContourConfiguration spec to be used when provisioning a Contour instance that will influence aspects of the Contour instance's runtime behavior.
 *
 * @schema ContourDeploymentSpecRuntimeSettings
 */
export interface ContourDeploymentSpecRuntimeSettings {
  /**
   * Debug contains parameters to enable debug logging and debug interfaces inside Contour.
   *
   * @schema ContourDeploymentSpecRuntimeSettings#debug
   */
  readonly debug?: ContourDeploymentSpecRuntimeSettingsDebug;

  /**
   * EnableExternalNameService allows processing of ExternalNameServices
   * Contour's default is false for security reasons.
   *
   * @schema ContourDeploymentSpecRuntimeSettings#enableExternalNameService
   */
  readonly enableExternalNameService?: boolean;

  /**
   * Envoy contains parameters for Envoy as well as how to optionally configure a managed Envoy fleet.
   *
   * @schema ContourDeploymentSpecRuntimeSettings#envoy
   */
  readonly envoy?: ContourDeploymentSpecRuntimeSettingsEnvoy;

  /**
   * Gateway contains parameters for the gateway-api Gateway that Contour is configured to serve traffic.
   *
   * @schema ContourDeploymentSpecRuntimeSettings#gateway
   */
  readonly gateway?: ContourDeploymentSpecRuntimeSettingsGateway;

  /**
   * Health defines the endpoints Contour uses to serve health checks.
   * Contour's default is { address: "0.0.0.0", port: 8000 }.
   *
   * @schema ContourDeploymentSpecRuntimeSettings#health
   */
  readonly health?: ContourDeploymentSpecRuntimeSettingsHealth;

  /**
   * HTTPProxy defines parameters on HTTPProxy.
   *
   * @schema ContourDeploymentSpecRuntimeSettings#httpproxy
   */
  readonly httpproxy?: ContourDeploymentSpecRuntimeSettingsHttpproxy;

  /**
   * Ingress contains parameters for ingress options.
   *
   * @schema ContourDeploymentSpecRuntimeSettings#ingress
   */
  readonly ingress?: ContourDeploymentSpecRuntimeSettingsIngress;

  /**
   * Metrics defines the endpoint Contour uses to serve metrics.
   * Contour's default is { address: "0.0.0.0", port: 8000 }.
   *
   * @schema ContourDeploymentSpecRuntimeSettings#metrics
   */
  readonly metrics?: ContourDeploymentSpecRuntimeSettingsMetrics;

  /**
   * Policy specifies default policy applied if not overridden by the user
   *
   * @schema ContourDeploymentSpecRuntimeSettings#policy
   */
  readonly policy?: ContourDeploymentSpecRuntimeSettingsPolicy;

  /**
   * RateLimitService optionally holds properties of the Rate Limit Service to be used for global rate limiting.
   *
   * @schema ContourDeploymentSpecRuntimeSettings#rateLimitService
   */
  readonly rateLimitService?: ContourDeploymentSpecRuntimeSettingsRateLimitService;

  /**
   * XDSServer contains parameters for the xDS server.
   *
   * @schema ContourDeploymentSpecRuntimeSettings#xdsServer
   */
  readonly xdsServer?: ContourDeploymentSpecRuntimeSettingsXdsServer;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettings(obj: ContourDeploymentSpecRuntimeSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'debug': toJson_ContourDeploymentSpecRuntimeSettingsDebug(obj.debug),
    'enableExternalNameService': obj.enableExternalNameService,
    'envoy': toJson_ContourDeploymentSpecRuntimeSettingsEnvoy(obj.envoy),
    'gateway': toJson_ContourDeploymentSpecRuntimeSettingsGateway(obj.gateway),
    'health': toJson_ContourDeploymentSpecRuntimeSettingsHealth(obj.health),
    'httpproxy': toJson_ContourDeploymentSpecRuntimeSettingsHttpproxy(obj.httpproxy),
    'ingress': toJson_ContourDeploymentSpecRuntimeSettingsIngress(obj.ingress),
    'metrics': toJson_ContourDeploymentSpecRuntimeSettingsMetrics(obj.metrics),
    'policy': toJson_ContourDeploymentSpecRuntimeSettingsPolicy(obj.policy),
    'rateLimitService': toJson_ContourDeploymentSpecRuntimeSettingsRateLimitService(obj.rateLimitService),
    'xdsServer': toJson_ContourDeploymentSpecRuntimeSettingsXdsServer(obj.xdsServer),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodePlacement describes node scheduling configuration of Contour pods.
 *
 * @schema ContourDeploymentSpecContourNodePlacement
 */
export interface ContourDeploymentSpecContourNodePlacement {
  /**
   * NodeSelector is the simplest recommended form of node selection constraint and specifies a map of key-value pairs. For the pod to be eligible to run on a node, the node must have each of the indicated key-value pairs as labels (it can have additional labels as well).
   * If unset, the pod(s) will be scheduled to any available node.
   *
   * @schema ContourDeploymentSpecContourNodePlacement#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Tolerations work with taints to ensure that pods are not scheduled onto inappropriate nodes. One or more taints are applied to a node; this marks that the node should not accept any pods that do not tolerate the taints.
   * The default is an empty list.
   * See https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/ for additional details.
   *
   * @schema ContourDeploymentSpecContourNodePlacement#tolerations
   */
  readonly tolerations?: ContourDeploymentSpecContourNodePlacementTolerations[];

}

/**
 * Converts an object of type 'ContourDeploymentSpecContourNodePlacement' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecContourNodePlacement(obj: ContourDeploymentSpecContourNodePlacement | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'tolerations': obj.tolerations?.map(y => toJson_ContourDeploymentSpecContourNodePlacementTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NetworkPublishing defines how to expose Envoy to a network.
 *
 * @schema ContourDeploymentSpecEnvoyNetworkPublishing
 */
export interface ContourDeploymentSpecEnvoyNetworkPublishing {
  /**
   * ServiceAnnotations is the annotations to add to the provisioned Envoy service.
   *
   * @schema ContourDeploymentSpecEnvoyNetworkPublishing#serviceAnnotations
   */
  readonly serviceAnnotations?: { [key: string]: string };

  /**
   * NetworkPublishingType is the type of publishing strategy to use. Valid values are:
   * * LoadBalancerService
   * In this configuration, network endpoints for Envoy use container networking. A Kubernetes LoadBalancer Service is created to publish Envoy network endpoints.
   * See: https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer
   * * NodePortService
   * Publishes Envoy network endpoints using a Kubernetes NodePort Service.
   * In this configuration, Envoy network endpoints use container networking. A Kubernetes NodePort Service is created to publish the network endpoints.
   * See: https://kubernetes.io/docs/concepts/services-networking/service/#nodeport
   * * ClusterIPService
   * Publishes Envoy network endpoints using a Kubernetes ClusterIP Service.
   * In this configuration, Envoy network endpoints use container networking. A Kubernetes ClusterIP Service is created to publish the network endpoints.
   * See: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
   * If unset, defaults to LoadBalancerService.
   *
   * @schema ContourDeploymentSpecEnvoyNetworkPublishing#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyNetworkPublishing' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyNetworkPublishing(obj: ContourDeploymentSpecEnvoyNetworkPublishing | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceAnnotations': ((obj.serviceAnnotations) === undefined) ? undefined : (Object.entries(obj.serviceAnnotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodePlacement describes node scheduling configuration of Envoy pods.
 *
 * @schema ContourDeploymentSpecEnvoyNodePlacement
 */
export interface ContourDeploymentSpecEnvoyNodePlacement {
  /**
   * NodeSelector is the simplest recommended form of node selection constraint and specifies a map of key-value pairs. For the pod to be eligible to run on a node, the node must have each of the indicated key-value pairs as labels (it can have additional labels as well).
   * If unset, the pod(s) will be scheduled to any available node.
   *
   * @schema ContourDeploymentSpecEnvoyNodePlacement#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Tolerations work with taints to ensure that pods are not scheduled onto inappropriate nodes. One or more taints are applied to a node; this marks that the node should not accept any pods that do not tolerate the taints.
   * The default is an empty list.
   * See https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/ for additional details.
   *
   * @schema ContourDeploymentSpecEnvoyNodePlacement#tolerations
   */
  readonly tolerations?: ContourDeploymentSpecEnvoyNodePlacementTolerations[];

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyNodePlacement' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyNodePlacement(obj: ContourDeploymentSpecEnvoyNodePlacement | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'tolerations': obj.tolerations?.map(y => toJson_ContourDeploymentSpecEnvoyNodePlacementTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Debug contains parameters to enable debug logging and debug interfaces inside Contour.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsDebug
 */
export interface ContourDeploymentSpecRuntimeSettingsDebug {
  /**
   * Defines the Contour debug address interface.
   * Contour's default is "127.0.0.1".
   *
   * @schema ContourDeploymentSpecRuntimeSettingsDebug#address
   */
  readonly address?: string;

  /**
   * Defines the Contour debug address port.
   * Contour's default is 6060.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsDebug#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsDebug' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsDebug(obj: ContourDeploymentSpecRuntimeSettingsDebug | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Envoy contains parameters for Envoy as well as how to optionally configure a managed Envoy fleet.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsEnvoy
 */
export interface ContourDeploymentSpecRuntimeSettingsEnvoy {
  /**
   * ClientCertificate defines the namespace/name of the Kubernetes secret containing the client certificate and private key to be used when establishing TLS connection to upstream cluster.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoy#clientCertificate
   */
  readonly clientCertificate?: ContourDeploymentSpecRuntimeSettingsEnvoyClientCertificate;

  /**
   * Cluster holds various configurable Envoy cluster values that can be set in the config file.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoy#cluster
   */
  readonly cluster?: ContourDeploymentSpecRuntimeSettingsEnvoyCluster;

  /**
   * DefaultHTTPVersions defines the default set of HTTPS versions the proxy should accept. HTTP versions are strings of the form "HTTP/xx". Supported versions are "HTTP/1.1" and "HTTP/2".
   * Values: `HTTP/1.1`, `HTTP/2` (default: both).
   * Other values will produce an error.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoy#defaultHTTPVersions
   */
  readonly defaultHttpVersions?: string[];

  /**
   * Health defines the endpoint Envoy uses to serve health checks.
   * Contour's default is { address: "0.0.0.0", port: 8002 }.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoy#health
   */
  readonly health?: ContourDeploymentSpecRuntimeSettingsEnvoyHealth;

  /**
   * Defines the HTTP Listener for Envoy.
   * Contour's default is { address: "0.0.0.0", port: 8080, accessLog: "/dev/stdout" }.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoy#http
   */
  readonly http?: ContourDeploymentSpecRuntimeSettingsEnvoyHttp;

  /**
   * Defines the HTTPS Listener for Envoy.
   * Contour's default is { address: "0.0.0.0", port: 8443, accessLog: "/dev/stdout" }.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoy#https
   */
  readonly https?: ContourDeploymentSpecRuntimeSettingsEnvoyHttps;

  /**
   * Listener hold various configurable Envoy listener values.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoy#listener
   */
  readonly listener?: ContourDeploymentSpecRuntimeSettingsEnvoyListener;

  /**
   * Logging defines how Envoy's logs can be configured.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoy#logging
   */
  readonly logging?: ContourDeploymentSpecRuntimeSettingsEnvoyLogging;

  /**
   * Metrics defines the endpoint Envoy uses to serve metrics.
   * Contour's default is { address: "0.0.0.0", port: 8002 }.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoy#metrics
   */
  readonly metrics?: ContourDeploymentSpecRuntimeSettingsEnvoyMetrics;

  /**
   * Network holds various configurable Envoy network values.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoy#network
   */
  readonly network?: ContourDeploymentSpecRuntimeSettingsEnvoyNetwork;

  /**
   * Service holds Envoy service parameters for setting Ingress status.
   * Contour's default is { namespace: "projectcontour", name: "envoy" }.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoy#service
   */
  readonly service?: ContourDeploymentSpecRuntimeSettingsEnvoyService;

  /**
   * Timeouts holds various configurable timeouts that can be set in the config file.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoy#timeouts
   */
  readonly timeouts?: ContourDeploymentSpecRuntimeSettingsEnvoyTimeouts;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsEnvoy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsEnvoy(obj: ContourDeploymentSpecRuntimeSettingsEnvoy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCertificate': toJson_ContourDeploymentSpecRuntimeSettingsEnvoyClientCertificate(obj.clientCertificate),
    'cluster': toJson_ContourDeploymentSpecRuntimeSettingsEnvoyCluster(obj.cluster),
    'defaultHTTPVersions': obj.defaultHttpVersions?.map(y => y),
    'health': toJson_ContourDeploymentSpecRuntimeSettingsEnvoyHealth(obj.health),
    'http': toJson_ContourDeploymentSpecRuntimeSettingsEnvoyHttp(obj.http),
    'https': toJson_ContourDeploymentSpecRuntimeSettingsEnvoyHttps(obj.https),
    'listener': toJson_ContourDeploymentSpecRuntimeSettingsEnvoyListener(obj.listener),
    'logging': toJson_ContourDeploymentSpecRuntimeSettingsEnvoyLogging(obj.logging),
    'metrics': toJson_ContourDeploymentSpecRuntimeSettingsEnvoyMetrics(obj.metrics),
    'network': toJson_ContourDeploymentSpecRuntimeSettingsEnvoyNetwork(obj.network),
    'service': toJson_ContourDeploymentSpecRuntimeSettingsEnvoyService(obj.service),
    'timeouts': toJson_ContourDeploymentSpecRuntimeSettingsEnvoyTimeouts(obj.timeouts),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Gateway contains parameters for the gateway-api Gateway that Contour is configured to serve traffic.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsGateway
 */
export interface ContourDeploymentSpecRuntimeSettingsGateway {
  /**
   * ControllerName is used to determine whether Contour should reconcile a GatewayClass. The string takes the form of "projectcontour.io/<namespace>/contour". If unset, the gatewayclass controller will not be started. Exactly one of ControllerName or GatewayRef must be set.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsGateway#controllerName
   */
  readonly controllerName?: string;

  /**
   * GatewayRef defines a specific Gateway that this Contour instance corresponds to. If set, Contour will reconcile only this gateway, and will not reconcile any gateway classes. Exactly one of ControllerName or GatewayRef must be set.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsGateway#gatewayRef
   */
  readonly gatewayRef?: ContourDeploymentSpecRuntimeSettingsGatewayGatewayRef;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsGateway' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsGateway(obj: ContourDeploymentSpecRuntimeSettingsGateway | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'controllerName': obj.controllerName,
    'gatewayRef': toJson_ContourDeploymentSpecRuntimeSettingsGatewayGatewayRef(obj.gatewayRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Health defines the endpoints Contour uses to serve health checks.
 * Contour's default is { address: "0.0.0.0", port: 8000 }.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsHealth
 */
export interface ContourDeploymentSpecRuntimeSettingsHealth {
  /**
   * Defines the health address interface.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsHealth#address
   */
  readonly address?: string;

  /**
   * Defines the health port.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsHealth#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsHealth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsHealth(obj: ContourDeploymentSpecRuntimeSettingsHealth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPProxy defines parameters on HTTPProxy.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsHttpproxy
 */
export interface ContourDeploymentSpecRuntimeSettingsHttpproxy {
  /**
   * DisablePermitInsecure disables the use of the permitInsecure field in HTTPProxy.
   * Contour's default is false.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsHttpproxy#disablePermitInsecure
   */
  readonly disablePermitInsecure?: boolean;

  /**
   * FallbackCertificate defines the namespace/name of the Kubernetes secret to use as fallback when a non-SNI request is received.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsHttpproxy#fallbackCertificate
   */
  readonly fallbackCertificate?: ContourDeploymentSpecRuntimeSettingsHttpproxyFallbackCertificate;

  /**
   * Restrict Contour to searching these namespaces for root ingress routes.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsHttpproxy#rootNamespaces
   */
  readonly rootNamespaces?: string[];

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsHttpproxy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsHttpproxy(obj: ContourDeploymentSpecRuntimeSettingsHttpproxy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disablePermitInsecure': obj.disablePermitInsecure,
    'fallbackCertificate': toJson_ContourDeploymentSpecRuntimeSettingsHttpproxyFallbackCertificate(obj.fallbackCertificate),
    'rootNamespaces': obj.rootNamespaces?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ingress contains parameters for ingress options.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsIngress
 */
export interface ContourDeploymentSpecRuntimeSettingsIngress {
  /**
   * Ingress Class Names Contour should use.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsIngress#classNames
   */
  readonly classNames?: string[];

  /**
   * Address to set in Ingress object status.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsIngress#statusAddress
   */
  readonly statusAddress?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsIngress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsIngress(obj: ContourDeploymentSpecRuntimeSettingsIngress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'classNames': obj.classNames?.map(y => y),
    'statusAddress': obj.statusAddress,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metrics defines the endpoint Contour uses to serve metrics.
 * Contour's default is { address: "0.0.0.0", port: 8000 }.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsMetrics
 */
export interface ContourDeploymentSpecRuntimeSettingsMetrics {
  /**
   * Defines the metrics address interface.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsMetrics#address
   */
  readonly address?: string;

  /**
   * Defines the metrics port.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsMetrics#port
   */
  readonly port?: number;

  /**
   * TLS holds TLS file config details. Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsMetrics#tls
   */
  readonly tls?: ContourDeploymentSpecRuntimeSettingsMetricsTls;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsMetrics(obj: ContourDeploymentSpecRuntimeSettingsMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'port': obj.port,
    'tls': toJson_ContourDeploymentSpecRuntimeSettingsMetricsTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policy specifies default policy applied if not overridden by the user
 *
 * @schema ContourDeploymentSpecRuntimeSettingsPolicy
 */
export interface ContourDeploymentSpecRuntimeSettingsPolicy {
  /**
   * ApplyToIngress determines if the Policies will apply to ingress objects
   * Contour's default is false.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsPolicy#applyToIngress
   */
  readonly applyToIngress?: boolean;

  /**
   * RequestHeadersPolicy defines the request headers set/removed on all routes
   *
   * @schema ContourDeploymentSpecRuntimeSettingsPolicy#requestHeaders
   */
  readonly requestHeaders?: ContourDeploymentSpecRuntimeSettingsPolicyRequestHeaders;

  /**
   * ResponseHeadersPolicy defines the response headers set/removed on all routes
   *
   * @schema ContourDeploymentSpecRuntimeSettingsPolicy#responseHeaders
   */
  readonly responseHeaders?: ContourDeploymentSpecRuntimeSettingsPolicyResponseHeaders;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsPolicy(obj: ContourDeploymentSpecRuntimeSettingsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyToIngress': obj.applyToIngress,
    'requestHeaders': toJson_ContourDeploymentSpecRuntimeSettingsPolicyRequestHeaders(obj.requestHeaders),
    'responseHeaders': toJson_ContourDeploymentSpecRuntimeSettingsPolicyResponseHeaders(obj.responseHeaders),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RateLimitService optionally holds properties of the Rate Limit Service to be used for global rate limiting.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsRateLimitService
 */
export interface ContourDeploymentSpecRuntimeSettingsRateLimitService {
  /**
   * Domain is passed to the Rate Limit Service.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsRateLimitService#domain
   */
  readonly domain?: string;

  /**
   * EnableXRateLimitHeaders defines whether to include the X-RateLimit headers X-RateLimit-Limit, X-RateLimit-Remaining, and X-RateLimit-Reset (as defined by the IETF Internet-Draft linked below), on responses to clients when the Rate Limit Service is consulted for a request.
   * ref. https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html
   *
   * @schema ContourDeploymentSpecRuntimeSettingsRateLimitService#enableXRateLimitHeaders
   */
  readonly enableXRateLimitHeaders?: boolean;

  /**
   * ExtensionService identifies the extension service defining the RLS.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsRateLimitService#extensionService
   */
  readonly extensionService: ContourDeploymentSpecRuntimeSettingsRateLimitServiceExtensionService;

  /**
   * FailOpen defines whether to allow requests to proceed when the Rate Limit Service fails to respond with a valid rate limit decision within the timeout defined on the extension service.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsRateLimitService#failOpen
   */
  readonly failOpen?: boolean;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsRateLimitService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsRateLimitService(obj: ContourDeploymentSpecRuntimeSettingsRateLimitService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domain': obj.domain,
    'enableXRateLimitHeaders': obj.enableXRateLimitHeaders,
    'extensionService': toJson_ContourDeploymentSpecRuntimeSettingsRateLimitServiceExtensionService(obj.extensionService),
    'failOpen': obj.failOpen,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * XDSServer contains parameters for the xDS server.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsXdsServer
 */
export interface ContourDeploymentSpecRuntimeSettingsXdsServer {
  /**
   * Defines the xDS gRPC API address which Contour will serve.
   * Contour's default is "0.0.0.0".
   *
   * @schema ContourDeploymentSpecRuntimeSettingsXdsServer#address
   */
  readonly address?: string;

  /**
   * Defines the xDS gRPC API port which Contour will serve.
   * Contour's default is 8001.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsXdsServer#port
   */
  readonly port?: number;

  /**
   * TLS holds TLS file config details.
   * Contour's default is { caFile: "/certs/ca.crt", certFile: "/certs/tls.cert", keyFile: "/certs/tls.key", insecure: false }.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsXdsServer#tls
   */
  readonly tls?: ContourDeploymentSpecRuntimeSettingsXdsServerTls;

  /**
   * Defines the XDSServer to use for `contour serve`.
   * Values: `contour` (default), `envoy`.
   * Other values will produce an error.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsXdsServer#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsXdsServer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsXdsServer(obj: ContourDeploymentSpecRuntimeSettingsXdsServer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'port': obj.port,
    'tls': toJson_ContourDeploymentSpecRuntimeSettingsXdsServerTls(obj.tls),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema ContourDeploymentSpecContourNodePlacementTolerations
 */
export interface ContourDeploymentSpecContourNodePlacementTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema ContourDeploymentSpecContourNodePlacementTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema ContourDeploymentSpecContourNodePlacementTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   *
   * @default Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   * @schema ContourDeploymentSpecContourNodePlacementTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema ContourDeploymentSpecContourNodePlacementTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema ContourDeploymentSpecContourNodePlacementTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecContourNodePlacementTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecContourNodePlacementTolerations(obj: ContourDeploymentSpecContourNodePlacementTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema ContourDeploymentSpecEnvoyNodePlacementTolerations
 */
export interface ContourDeploymentSpecEnvoyNodePlacementTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema ContourDeploymentSpecEnvoyNodePlacementTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema ContourDeploymentSpecEnvoyNodePlacementTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   *
   * @default Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   * @schema ContourDeploymentSpecEnvoyNodePlacementTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema ContourDeploymentSpecEnvoyNodePlacementTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema ContourDeploymentSpecEnvoyNodePlacementTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyNodePlacementTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyNodePlacementTolerations(obj: ContourDeploymentSpecEnvoyNodePlacementTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClientCertificate defines the namespace/name of the Kubernetes secret containing the client certificate and private key to be used when establishing TLS connection to upstream cluster.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsEnvoyClientCertificate
 */
export interface ContourDeploymentSpecRuntimeSettingsEnvoyClientCertificate {
  /**
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyClientCertificate#name
   */
  readonly name: string;

  /**
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyClientCertificate#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsEnvoyClientCertificate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsEnvoyClientCertificate(obj: ContourDeploymentSpecRuntimeSettingsEnvoyClientCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cluster holds various configurable Envoy cluster values that can be set in the config file.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsEnvoyCluster
 */
export interface ContourDeploymentSpecRuntimeSettingsEnvoyCluster {
  /**
   * DNSLookupFamily defines how external names are looked up When configured as V4, the DNS resolver will only perform a lookup for addresses in the IPv4 family. If V6 is configured, the DNS resolver will only perform a lookup for addresses in the IPv6 family. If AUTO is configured, the DNS resolver will first perform a lookup for addresses in the IPv6 family and fallback to a lookup for addresses in the IPv4 family. Note: This only applies to externalName clusters.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-enum-config-cluster-v3-cluster-dnslookupfamily for more information.
   * Values: `auto` (default), `v4`, `v6`.
   * Other values will produce an error.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyCluster#dnsLookupFamily
   */
  readonly dnsLookupFamily?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsEnvoyCluster' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsEnvoyCluster(obj: ContourDeploymentSpecRuntimeSettingsEnvoyCluster | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsLookupFamily': obj.dnsLookupFamily,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Health defines the endpoint Envoy uses to serve health checks.
 * Contour's default is { address: "0.0.0.0", port: 8002 }.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsEnvoyHealth
 */
export interface ContourDeploymentSpecRuntimeSettingsEnvoyHealth {
  /**
   * Defines the health address interface.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyHealth#address
   */
  readonly address?: string;

  /**
   * Defines the health port.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyHealth#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsEnvoyHealth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsEnvoyHealth(obj: ContourDeploymentSpecRuntimeSettingsEnvoyHealth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the HTTP Listener for Envoy.
 * Contour's default is { address: "0.0.0.0", port: 8080, accessLog: "/dev/stdout" }.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsEnvoyHttp
 */
export interface ContourDeploymentSpecRuntimeSettingsEnvoyHttp {
  /**
   * AccessLog defines where Envoy logs are outputted for this listener.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyHttp#accessLog
   */
  readonly accessLog?: string;

  /**
   * Defines an Envoy Listener Address.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyHttp#address
   */
  readonly address?: string;

  /**
   * Defines an Envoy listener Port.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyHttp#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsEnvoyHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsEnvoyHttp(obj: ContourDeploymentSpecRuntimeSettingsEnvoyHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessLog': obj.accessLog,
    'address': obj.address,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the HTTPS Listener for Envoy.
 * Contour's default is { address: "0.0.0.0", port: 8443, accessLog: "/dev/stdout" }.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsEnvoyHttps
 */
export interface ContourDeploymentSpecRuntimeSettingsEnvoyHttps {
  /**
   * AccessLog defines where Envoy logs are outputted for this listener.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyHttps#accessLog
   */
  readonly accessLog?: string;

  /**
   * Defines an Envoy Listener Address.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyHttps#address
   */
  readonly address?: string;

  /**
   * Defines an Envoy listener Port.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyHttps#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsEnvoyHttps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsEnvoyHttps(obj: ContourDeploymentSpecRuntimeSettingsEnvoyHttps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessLog': obj.accessLog,
    'address': obj.address,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Listener hold various configurable Envoy listener values.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsEnvoyListener
 */
export interface ContourDeploymentSpecRuntimeSettingsEnvoyListener {
  /**
   * ConnectionBalancer. If the value is exact, the listener will use the exact connection balancer See https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/listener.proto#envoy-api-msg-listener-connectionbalanceconfig for more information.
   * Values: (empty string): use the default ConnectionBalancer, `exact`: use the Exact ConnectionBalancer.
   * Other values will produce an error.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyListener#connectionBalancer
   */
  readonly connectionBalancer?: string;

  /**
   * DisableAllowChunkedLength disables the RFC-compliant Envoy behavior to strip the "Content-Length" header if "Transfer-Encoding: chunked" is also set. This is an emergency off-switch to revert back to Envoy's default behavior in case of failures. Please file an issue if failures are encountered. See: https://github.com/projectcontour/contour/issues/3221
   * Contour's default is false.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyListener#disableAllowChunkedLength
   */
  readonly disableAllowChunkedLength?: boolean;

  /**
   * DisableMergeSlashes disables Envoy's non-standard merge_slashes path transformation option which strips duplicate slashes from request URL paths.
   * Contour's default is false.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyListener#disableMergeSlashes
   */
  readonly disableMergeSlashes?: boolean;

  /**
   * TLS holds various configurable Envoy TLS listener values.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyListener#tls
   */
  readonly tls?: ContourDeploymentSpecRuntimeSettingsEnvoyListenerTls;

  /**
   * Use PROXY protocol for all listeners.
   * Contour's default is false.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyListener#useProxyProtocol
   */
  readonly useProxyProtocol?: boolean;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsEnvoyListener' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsEnvoyListener(obj: ContourDeploymentSpecRuntimeSettingsEnvoyListener | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionBalancer': obj.connectionBalancer,
    'disableAllowChunkedLength': obj.disableAllowChunkedLength,
    'disableMergeSlashes': obj.disableMergeSlashes,
    'tls': toJson_ContourDeploymentSpecRuntimeSettingsEnvoyListenerTls(obj.tls),
    'useProxyProtocol': obj.useProxyProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Logging defines how Envoy's logs can be configured.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsEnvoyLogging
 */
export interface ContourDeploymentSpecRuntimeSettingsEnvoyLogging {
  /**
   * AccessLogFormat sets the global access log format.
   * Values: `envoy` (default), `json`.
   * Other values will produce an error.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyLogging#accessLogFormat
   */
  readonly accessLogFormat?: string;

  /**
   * AccessLogFormatString sets the access log format when format is set to `envoy`. When empty, Envoy's default format is used.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyLogging#accessLogFormatString
   */
  readonly accessLogFormatString?: string;

  /**
   * AccessLogJSONFields sets the fields that JSON logging will output when AccessLogFormat is json.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyLogging#accessLogJSONFields
   */
  readonly accessLogJsonFields?: string[];

  /**
   * AccessLogLevel sets the verbosity level of the access log.
   * Values: `info` (default, meaning all requests are logged), `error` and `disabled`.
   * Other values will produce an error.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyLogging#accessLogLevel
   */
  readonly accessLogLevel?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsEnvoyLogging' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsEnvoyLogging(obj: ContourDeploymentSpecRuntimeSettingsEnvoyLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessLogFormat': obj.accessLogFormat,
    'accessLogFormatString': obj.accessLogFormatString,
    'accessLogJSONFields': obj.accessLogJsonFields?.map(y => y),
    'accessLogLevel': obj.accessLogLevel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metrics defines the endpoint Envoy uses to serve metrics.
 * Contour's default is { address: "0.0.0.0", port: 8002 }.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsEnvoyMetrics
 */
export interface ContourDeploymentSpecRuntimeSettingsEnvoyMetrics {
  /**
   * Defines the metrics address interface.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyMetrics#address
   */
  readonly address?: string;

  /**
   * Defines the metrics port.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyMetrics#port
   */
  readonly port?: number;

  /**
   * TLS holds TLS file config details. Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyMetrics#tls
   */
  readonly tls?: ContourDeploymentSpecRuntimeSettingsEnvoyMetricsTls;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsEnvoyMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsEnvoyMetrics(obj: ContourDeploymentSpecRuntimeSettingsEnvoyMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'port': obj.port,
    'tls': toJson_ContourDeploymentSpecRuntimeSettingsEnvoyMetricsTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Network holds various configurable Envoy network values.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsEnvoyNetwork
 */
export interface ContourDeploymentSpecRuntimeSettingsEnvoyNetwork {
  /**
   * Configure the port used to access the Envoy Admin interface. If configured to port "0" then the admin interface is disabled.
   * Contour's default is 9001.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyNetwork#adminPort
   */
  readonly adminPort?: number;

  /**
   * XffNumTrustedHops defines the number of additional ingress proxy hops from the right side of the x-forwarded-for HTTP header to trust when determining the origin client’s IP address.
   * See https://www.envoyproxy.io/docs/envoy/v1.17.0/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto?highlight=xff_num_trusted_hops for more information.
   * Contour's default is 0.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyNetwork#numTrustedHops
   */
  readonly numTrustedHops?: number;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsEnvoyNetwork' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsEnvoyNetwork(obj: ContourDeploymentSpecRuntimeSettingsEnvoyNetwork | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'adminPort': obj.adminPort,
    'numTrustedHops': obj.numTrustedHops,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Service holds Envoy service parameters for setting Ingress status.
 * Contour's default is { namespace: "projectcontour", name: "envoy" }.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsEnvoyService
 */
export interface ContourDeploymentSpecRuntimeSettingsEnvoyService {
  /**
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyService#name
   */
  readonly name: string;

  /**
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyService#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsEnvoyService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsEnvoyService(obj: ContourDeploymentSpecRuntimeSettingsEnvoyService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Timeouts holds various configurable timeouts that can be set in the config file.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsEnvoyTimeouts
 */
export interface ContourDeploymentSpecRuntimeSettingsEnvoyTimeouts {
  /**
   * ConnectTimeout defines how long the proxy should wait when establishing connection to upstream service. If not set, a default value of 2 seconds will be used.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#envoy-v3-api-field-config-cluster-v3-cluster-connect-timeout for more information.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyTimeouts#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * ConnectionIdleTimeout defines how long the proxy should wait while there are no active requests (for HTTP/1.1) or streams (for HTTP/2) before terminating an HTTP connection. Set to "infinity" to disable the timeout entirely.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-idle-timeout for more information.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyTimeouts#connectionIdleTimeout
   */
  readonly connectionIdleTimeout?: string;

  /**
   * ConnectionShutdownGracePeriod defines how long the proxy will wait between sending an initial GOAWAY frame and a second, final GOAWAY frame when terminating an HTTP/2 connection. During this grace period, the proxy will continue to respond to new streams. After the final GOAWAY frame has been sent, the proxy will refuse new streams.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-drain-timeout for more information.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyTimeouts#connectionShutdownGracePeriod
   */
  readonly connectionShutdownGracePeriod?: string;

  /**
   * DelayedCloseTimeout defines how long envoy will wait, once connection close processing has been initiated, for the downstream peer to close the connection before Envoy closes the socket associated with the connection.
   * Setting this timeout to 'infinity' will disable it, equivalent to setting it to '0' in Envoy. Leaving it unset will result in the Envoy default value being used.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-delayed-close-timeout for more information.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyTimeouts#delayedCloseTimeout
   */
  readonly delayedCloseTimeout?: string;

  /**
   * MaxConnectionDuration defines the maximum period of time after an HTTP connection has been established from the client to the proxy before it is closed by the proxy, regardless of whether there has been activity or not. Omit or set to "infinity" for no max duration.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-max-connection-duration for more information.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyTimeouts#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * RequestTimeout sets the client request timeout globally for Contour. Note that this is a timeout for the entire request, not an idle timeout. Omit or set to "infinity" to disable the timeout entirely.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-request-timeout for more information.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyTimeouts#requestTimeout
   */
  readonly requestTimeout?: string;

  /**
   * StreamIdleTimeout defines how long the proxy should wait while there is no request activity (for HTTP/1.1) or stream activity (for HTTP/2) before terminating the HTTP request or stream. Set to "infinity" to disable the timeout entirely.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-stream-idle-timeout for more information.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyTimeouts#streamIdleTimeout
   */
  readonly streamIdleTimeout?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsEnvoyTimeouts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsEnvoyTimeouts(obj: ContourDeploymentSpecRuntimeSettingsEnvoyTimeouts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'connectionIdleTimeout': obj.connectionIdleTimeout,
    'connectionShutdownGracePeriod': obj.connectionShutdownGracePeriod,
    'delayedCloseTimeout': obj.delayedCloseTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'requestTimeout': obj.requestTimeout,
    'streamIdleTimeout': obj.streamIdleTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GatewayRef defines a specific Gateway that this Contour instance corresponds to. If set, Contour will reconcile only this gateway, and will not reconcile any gateway classes. Exactly one of ControllerName or GatewayRef must be set.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsGatewayGatewayRef
 */
export interface ContourDeploymentSpecRuntimeSettingsGatewayGatewayRef {
  /**
   * @schema ContourDeploymentSpecRuntimeSettingsGatewayGatewayRef#name
   */
  readonly name: string;

  /**
   * @schema ContourDeploymentSpecRuntimeSettingsGatewayGatewayRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsGatewayGatewayRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsGatewayGatewayRef(obj: ContourDeploymentSpecRuntimeSettingsGatewayGatewayRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FallbackCertificate defines the namespace/name of the Kubernetes secret to use as fallback when a non-SNI request is received.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsHttpproxyFallbackCertificate
 */
export interface ContourDeploymentSpecRuntimeSettingsHttpproxyFallbackCertificate {
  /**
   * @schema ContourDeploymentSpecRuntimeSettingsHttpproxyFallbackCertificate#name
   */
  readonly name: string;

  /**
   * @schema ContourDeploymentSpecRuntimeSettingsHttpproxyFallbackCertificate#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsHttpproxyFallbackCertificate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsHttpproxyFallbackCertificate(obj: ContourDeploymentSpecRuntimeSettingsHttpproxyFallbackCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS holds TLS file config details. Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsMetricsTls
 */
export interface ContourDeploymentSpecRuntimeSettingsMetricsTls {
  /**
   * CA filename.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsMetricsTls#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate filename.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsMetricsTls#certFile
   */
  readonly certFile?: string;

  /**
   * Client key filename.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsMetricsTls#keyFile
   */
  readonly keyFile?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsMetricsTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsMetricsTls(obj: ContourDeploymentSpecRuntimeSettingsMetricsTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caFile': obj.caFile,
    'certFile': obj.certFile,
    'keyFile': obj.keyFile,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RequestHeadersPolicy defines the request headers set/removed on all routes
 *
 * @schema ContourDeploymentSpecRuntimeSettingsPolicyRequestHeaders
 */
export interface ContourDeploymentSpecRuntimeSettingsPolicyRequestHeaders {
  /**
   * @schema ContourDeploymentSpecRuntimeSettingsPolicyRequestHeaders#remove
   */
  readonly remove?: string[];

  /**
   * @schema ContourDeploymentSpecRuntimeSettingsPolicyRequestHeaders#set
   */
  readonly set?: { [key: string]: string };

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsPolicyRequestHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsPolicyRequestHeaders(obj: ContourDeploymentSpecRuntimeSettingsPolicyRequestHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'remove': obj.remove?.map(y => y),
    'set': ((obj.set) === undefined) ? undefined : (Object.entries(obj.set).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResponseHeadersPolicy defines the response headers set/removed on all routes
 *
 * @schema ContourDeploymentSpecRuntimeSettingsPolicyResponseHeaders
 */
export interface ContourDeploymentSpecRuntimeSettingsPolicyResponseHeaders {
  /**
   * @schema ContourDeploymentSpecRuntimeSettingsPolicyResponseHeaders#remove
   */
  readonly remove?: string[];

  /**
   * @schema ContourDeploymentSpecRuntimeSettingsPolicyResponseHeaders#set
   */
  readonly set?: { [key: string]: string };

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsPolicyResponseHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsPolicyResponseHeaders(obj: ContourDeploymentSpecRuntimeSettingsPolicyResponseHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'remove': obj.remove?.map(y => y),
    'set': ((obj.set) === undefined) ? undefined : (Object.entries(obj.set).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExtensionService identifies the extension service defining the RLS.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsRateLimitServiceExtensionService
 */
export interface ContourDeploymentSpecRuntimeSettingsRateLimitServiceExtensionService {
  /**
   * @schema ContourDeploymentSpecRuntimeSettingsRateLimitServiceExtensionService#name
   */
  readonly name: string;

  /**
   * @schema ContourDeploymentSpecRuntimeSettingsRateLimitServiceExtensionService#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsRateLimitServiceExtensionService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsRateLimitServiceExtensionService(obj: ContourDeploymentSpecRuntimeSettingsRateLimitServiceExtensionService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS holds TLS file config details.
 * Contour's default is { caFile: "/certs/ca.crt", certFile: "/certs/tls.cert", keyFile: "/certs/tls.key", insecure: false }.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsXdsServerTls
 */
export interface ContourDeploymentSpecRuntimeSettingsXdsServerTls {
  /**
   * CA filename.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsXdsServerTls#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate filename.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsXdsServerTls#certFile
   */
  readonly certFile?: string;

  /**
   * Allow serving the xDS gRPC API without TLS.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsXdsServerTls#insecure
   */
  readonly insecure?: boolean;

  /**
   * Client key filename.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsXdsServerTls#keyFile
   */
  readonly keyFile?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsXdsServerTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsXdsServerTls(obj: ContourDeploymentSpecRuntimeSettingsXdsServerTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caFile': obj.caFile,
    'certFile': obj.certFile,
    'insecure': obj.insecure,
    'keyFile': obj.keyFile,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS holds various configurable Envoy TLS listener values.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsEnvoyListenerTls
 */
export interface ContourDeploymentSpecRuntimeSettingsEnvoyListenerTls {
  /**
   * CipherSuites defines the TLS ciphers to be supported by Envoy TLS listeners when negotiating TLS 1.2. Ciphers are validated against the set that Envoy supports by default. This parameter should only be used by advanced users. Note that these will be ignored when TLS 1.3 is in use.
   * This field is optional; when it is undefined, a Contour-managed ciphersuite list will be used, which may be updated to keep it secure.
   * Contour's default list is:   - "[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]"   - "[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]"   - "ECDHE-ECDSA-AES256-GCM-SHA384"   - "ECDHE-RSA-AES256-GCM-SHA384"
   * Ciphers provided are validated against the following list:   - "[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]"   - "[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]"   - "ECDHE-ECDSA-AES128-GCM-SHA256"   - "ECDHE-RSA-AES128-GCM-SHA256"   - "ECDHE-ECDSA-AES128-SHA"   - "ECDHE-RSA-AES128-SHA"   - "AES128-GCM-SHA256"   - "AES128-SHA"   - "ECDHE-ECDSA-AES256-GCM-SHA384"   - "ECDHE-RSA-AES256-GCM-SHA384"   - "ECDHE-ECDSA-AES256-SHA"   - "ECDHE-RSA-AES256-SHA"   - "AES256-GCM-SHA384"   - "AES256-SHA"
   * Contour recommends leaving this undefined unless you are sure you must.
   * See: https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/transport_sockets/tls/v3/common.proto#extensions-transport-sockets-tls-v3-tlsparameters Note: This list is a superset of what is valid for stock Envoy builds and those using BoringSSL FIPS.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyListenerTls#cipherSuites
   */
  readonly cipherSuites?: string[];

  /**
   * MinimumProtocolVersion is the minimum TLS version this vhost should negotiate.
   * Values: `1.2` (default), `1.3`.
   * Other values will produce an error.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyListenerTls#minimumProtocolVersion
   */
  readonly minimumProtocolVersion?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsEnvoyListenerTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsEnvoyListenerTls(obj: ContourDeploymentSpecRuntimeSettingsEnvoyListenerTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cipherSuites': obj.cipherSuites?.map(y => y),
    'minimumProtocolVersion': obj.minimumProtocolVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS holds TLS file config details. Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsEnvoyMetricsTls
 */
export interface ContourDeploymentSpecRuntimeSettingsEnvoyMetricsTls {
  /**
   * CA filename.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyMetricsTls#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate filename.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyMetricsTls#certFile
   */
  readonly certFile?: string;

  /**
   * Client key filename.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyMetricsTls#keyFile
   */
  readonly keyFile?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsEnvoyMetricsTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsEnvoyMetricsTls(obj: ContourDeploymentSpecRuntimeSettingsEnvoyMetricsTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caFile': obj.caFile,
    'certFile': obj.certFile,
    'keyFile': obj.keyFile,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * ExtensionService is the schema for the Contour extension services API. An ExtensionService resource binds a network service to the Contour API so that Contour API features can be implemented by collaborating components.
 *
 * @schema ExtensionService
 */
export class ExtensionService extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ExtensionService"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'projectcontour.io/v1alpha1',
    kind: 'ExtensionService',
  }

  /**
   * Renders a Kubernetes manifest for "ExtensionService".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ExtensionServiceProps = {}): any {
    return {
      ...ExtensionService.GVK,
      ...toJson_ExtensionServiceProps(props),
    };
  }

  /**
   * Defines a "ExtensionService" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ExtensionServiceProps = {}) {
    super(scope, id, {
      ...ExtensionService.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ExtensionService.GVK,
      ...toJson_ExtensionServiceProps(resolved),
    };
  }
}

/**
 * ExtensionService is the schema for the Contour extension services API. An ExtensionService resource binds a network service to the Contour API so that Contour API features can be implemented by collaborating components.
 *
 * @schema ExtensionService
 */
export interface ExtensionServiceProps {
  /**
   * @schema ExtensionService#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ExtensionServiceSpec defines the desired state of an ExtensionService resource.
   *
   * @schema ExtensionService#spec
   */
  readonly spec?: ExtensionServiceSpec;

}

/**
 * Converts an object of type 'ExtensionServiceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionServiceProps(obj: ExtensionServiceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ExtensionServiceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExtensionServiceSpec defines the desired state of an ExtensionService resource.
 *
 * @schema ExtensionServiceSpec
 */
export interface ExtensionServiceSpec {
  /**
   * The policy for load balancing GRPC service requests. Note that the `Cookie` and `RequestHash` load balancing strategies cannot be used here.
   *
   * @schema ExtensionServiceSpec#loadBalancerPolicy
   */
  readonly loadBalancerPolicy?: ExtensionServiceSpecLoadBalancerPolicy;

  /**
   * Protocol may be used to specify (or override) the protocol used to reach this Service. Values may be h2 or h2c. If omitted, protocol-selection falls back on Service annotations.
   *
   * @schema ExtensionServiceSpec#protocol
   */
  readonly protocol?: ExtensionServiceSpecProtocol;

  /**
   * This field sets the version of the GRPC protocol that Envoy uses to send requests to the extension service. Since Contour always uses the v3 Envoy API, this is currently fixed at "v3". However, other protocol options will be available in future.
   *
   * @schema ExtensionServiceSpec#protocolVersion
   */
  readonly protocolVersion?: ExtensionServiceSpecProtocolVersion;

  /**
   * Services specifies the set of Kubernetes Service resources that receive GRPC extension API requests. If no weights are specified for any of the entries in this array, traffic will be spread evenly across all the services. Otherwise, traffic is balanced proportionally to the Weight field in each entry.
   *
   * @schema ExtensionServiceSpec#services
   */
  readonly services: ExtensionServiceSpecServices[];

  /**
   * The timeout policy for requests to the services.
   *
   * @schema ExtensionServiceSpec#timeoutPolicy
   */
  readonly timeoutPolicy?: ExtensionServiceSpecTimeoutPolicy;

  /**
   * UpstreamValidation defines how to verify the backend service's certificate
   *
   * @schema ExtensionServiceSpec#validation
   */
  readonly validation?: ExtensionServiceSpecValidation;

}

/**
 * Converts an object of type 'ExtensionServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionServiceSpec(obj: ExtensionServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'loadBalancerPolicy': toJson_ExtensionServiceSpecLoadBalancerPolicy(obj.loadBalancerPolicy),
    'protocol': obj.protocol,
    'protocolVersion': obj.protocolVersion,
    'services': obj.services?.map(y => toJson_ExtensionServiceSpecServices(y)),
    'timeoutPolicy': toJson_ExtensionServiceSpecTimeoutPolicy(obj.timeoutPolicy),
    'validation': toJson_ExtensionServiceSpecValidation(obj.validation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The policy for load balancing GRPC service requests. Note that the `Cookie` and `RequestHash` load balancing strategies cannot be used here.
 *
 * @schema ExtensionServiceSpecLoadBalancerPolicy
 */
export interface ExtensionServiceSpecLoadBalancerPolicy {
  /**
   * RequestHashPolicies contains a list of hash policies to apply when the `RequestHash` load balancing strategy is chosen. If an element of the supplied list of hash policies is invalid, it will be ignored. If the list of hash policies is empty after validation, the load balancing strategy will fall back the the default `RoundRobin`.
   *
   * @schema ExtensionServiceSpecLoadBalancerPolicy#requestHashPolicies
   */
  readonly requestHashPolicies?: ExtensionServiceSpecLoadBalancerPolicyRequestHashPolicies[];

  /**
   * Strategy specifies the policy used to balance requests across the pool of backend pods. Valid policy names are `Random`, `RoundRobin`, `WeightedLeastRequest`, `Cookie`, and `RequestHash`. If an unknown strategy name is specified or no policy is supplied, the default `RoundRobin` policy is used.
   *
   * @schema ExtensionServiceSpecLoadBalancerPolicy#strategy
   */
  readonly strategy?: string;

}

/**
 * Converts an object of type 'ExtensionServiceSpecLoadBalancerPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionServiceSpecLoadBalancerPolicy(obj: ExtensionServiceSpecLoadBalancerPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'requestHashPolicies': obj.requestHashPolicies?.map(y => toJson_ExtensionServiceSpecLoadBalancerPolicyRequestHashPolicies(y)),
    'strategy': obj.strategy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Protocol may be used to specify (or override) the protocol used to reach this Service. Values may be h2 or h2c. If omitted, protocol-selection falls back on Service annotations.
 *
 * @schema ExtensionServiceSpecProtocol
 */
export enum ExtensionServiceSpecProtocol {
  /** h2 */
  H2 = 'h2',
  /** h2c */
  H2C = 'h2c',
}

/**
 * This field sets the version of the GRPC protocol that Envoy uses to send requests to the extension service. Since Contour always uses the v3 Envoy API, this is currently fixed at "v3". However, other protocol options will be available in future.
 *
 * @schema ExtensionServiceSpecProtocolVersion
 */
export enum ExtensionServiceSpecProtocolVersion {
  /** v3 */
  V3 = 'v3',
}

/**
 * ExtensionServiceTarget defines an Kubernetes Service to target with extension service traffic.
 *
 * @schema ExtensionServiceSpecServices
 */
export interface ExtensionServiceSpecServices {
  /**
   * Name is the name of Kubernetes service that will accept service traffic.
   *
   * @schema ExtensionServiceSpecServices#name
   */
  readonly name: string;

  /**
   * Port (defined as Integer) to proxy traffic to since a service can have multiple defined.
   *
   * @schema ExtensionServiceSpecServices#port
   */
  readonly port: number;

  /**
   * Weight defines proportion of traffic to balance to the Kubernetes Service.
   *
   * @schema ExtensionServiceSpecServices#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'ExtensionServiceSpecServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionServiceSpecServices(obj: ExtensionServiceSpecServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'port': obj.port,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The timeout policy for requests to the services.
 *
 * @schema ExtensionServiceSpecTimeoutPolicy
 */
export interface ExtensionServiceSpecTimeoutPolicy {
  /**
   * Timeout for how long the proxy should wait while there is no activity during single request/response (for HTTP/1.1) or stream (for HTTP/2). Timeout will not trigger while HTTP/1.1 connection is idle between two consecutive requests. If not specified, there is no per-route idle timeout, though a connection manager-wide stream_idle_timeout default of 5m still applies.
   *
   * @schema ExtensionServiceSpecTimeoutPolicy#idle
   */
  readonly idle?: string;

  /**
   * Timeout for how long connection from the proxy to the upstream service is kept when there are no active requests. If not supplied, Envoy's default value of 1h applies.
   *
   * @schema ExtensionServiceSpecTimeoutPolicy#idleConnection
   */
  readonly idleConnection?: string;

  /**
   * Timeout for receiving a response from the server after processing a request from client. If not supplied, Envoy's default value of 15s applies.
   *
   * @schema ExtensionServiceSpecTimeoutPolicy#response
   */
  readonly response?: string;

}

/**
 * Converts an object of type 'ExtensionServiceSpecTimeoutPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionServiceSpecTimeoutPolicy(obj: ExtensionServiceSpecTimeoutPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idle': obj.idle,
    'idleConnection': obj.idleConnection,
    'response': obj.response,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UpstreamValidation defines how to verify the backend service's certificate
 *
 * @schema ExtensionServiceSpecValidation
 */
export interface ExtensionServiceSpecValidation {
  /**
   * Name or namespaced name of the Kubernetes secret used to validate the certificate presented by the backend. The secret must contain key named ca.crt.
   *
   * @schema ExtensionServiceSpecValidation#caSecret
   */
  readonly caSecret: string;

  /**
   * Key which is expected to be present in the 'subjectAltName' of the presented certificate.
   *
   * @schema ExtensionServiceSpecValidation#subjectName
   */
  readonly subjectName: string;

}

/**
 * Converts an object of type 'ExtensionServiceSpecValidation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionServiceSpecValidation(obj: ExtensionServiceSpecValidation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caSecret': obj.caSecret,
    'subjectName': obj.subjectName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RequestHashPolicy contains configuration for an individual hash policy on a request attribute.
 *
 * @schema ExtensionServiceSpecLoadBalancerPolicyRequestHashPolicies
 */
export interface ExtensionServiceSpecLoadBalancerPolicyRequestHashPolicies {
  /**
   * HashSourceIP should be set to true when request source IP hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.
   *
   * @schema ExtensionServiceSpecLoadBalancerPolicyRequestHashPolicies#hashSourceIP
   */
  readonly hashSourceIp?: boolean;

  /**
   * HeaderHashOptions should be set when request header hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.
   *
   * @schema ExtensionServiceSpecLoadBalancerPolicyRequestHashPolicies#headerHashOptions
   */
  readonly headerHashOptions?: ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions;

  /**
   * QueryParameterHashOptions should be set when request query parameter hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.
   *
   * @schema ExtensionServiceSpecLoadBalancerPolicyRequestHashPolicies#queryParameterHashOptions
   */
  readonly queryParameterHashOptions?: ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions;

  /**
   * Terminal is a flag that allows for short-circuiting computing of a hash for a given request. If set to true, and the request attribute specified in the attribute hash options is present, no further hash policies will be used to calculate a hash for the request.
   *
   * @schema ExtensionServiceSpecLoadBalancerPolicyRequestHashPolicies#terminal
   */
  readonly terminal?: boolean;

}

/**
 * Converts an object of type 'ExtensionServiceSpecLoadBalancerPolicyRequestHashPolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionServiceSpecLoadBalancerPolicyRequestHashPolicies(obj: ExtensionServiceSpecLoadBalancerPolicyRequestHashPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hashSourceIP': obj.hashSourceIp,
    'headerHashOptions': toJson_ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions(obj.headerHashOptions),
    'queryParameterHashOptions': toJson_ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions(obj.queryParameterHashOptions),
    'terminal': obj.terminal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HeaderHashOptions should be set when request header hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.
 *
 * @schema ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions
 */
export interface ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions {
  /**
   * HeaderName is the name of the HTTP request header that will be used to calculate the hash key. If the header specified is not present on a request, no hash will be produced.
   *
   * @schema ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions#headerName
   */
  readonly headerName?: string;

}

/**
 * Converts an object of type 'ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions(obj: ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerName': obj.headerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * QueryParameterHashOptions should be set when request query parameter hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.
 *
 * @schema ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions
 */
export interface ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions {
  /**
   * ParameterName is the name of the HTTP request query parameter that will be used to calculate the hash key. If the query parameter specified is not present on a request, no hash will be produced.
   *
   * @schema ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions#parameterName
   */
  readonly parameterName?: string;

}

/**
 * Converts an object of type 'ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions(obj: ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameterName': obj.parameterName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * HTTPProxy is an Ingress CRD specification.
 *
 * @schema HTTPProxy
 */
export class HttpProxy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HTTPProxy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'projectcontour.io/v1',
    kind: 'HTTPProxy',
  }

  /**
   * Renders a Kubernetes manifest for "HTTPProxy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HttpProxyProps): any {
    return {
      ...HttpProxy.GVK,
      ...toJson_HttpProxyProps(props),
    };
  }

  /**
   * Defines a "HTTPProxy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HttpProxyProps) {
    super(scope, id, {
      ...HttpProxy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...HttpProxy.GVK,
      ...toJson_HttpProxyProps(resolved),
    };
  }
}

/**
 * HTTPProxy is an Ingress CRD specification.
 *
 * @schema HTTPProxy
 */
export interface HttpProxyProps {
  /**
   * @schema HTTPProxy#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * HTTPProxySpec defines the spec of the CRD.
   *
   * @schema HTTPProxy#spec
   */
  readonly spec: HttpProxySpec;

}

/**
 * Converts an object of type 'HttpProxyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxyProps(obj: HttpProxyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HttpProxySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPProxySpec defines the spec of the CRD.
 *
 * @schema HttpProxySpec
 */
export interface HttpProxySpec {
  /**
   * Includes allow for specific routing configuration to be included from another HTTPProxy, possibly in another namespace.
   *
   * @schema HttpProxySpec#includes
   */
  readonly includes?: HttpProxySpecIncludes[];

  /**
   * IngressClassName optionally specifies the ingress class to use for this HTTPProxy. This replaces the deprecated `kubernetes.io/ingress.class` annotation. For backwards compatibility, when that annotation is set, it is given precedence over this field.
   *
   * @schema HttpProxySpec#ingressClassName
   */
  readonly ingressClassName?: string;

  /**
   * Routes are the ingress routes. If TCPProxy is present, Routes is ignored.
   *
   * @schema HttpProxySpec#routes
   */
  readonly routes?: HttpProxySpecRoutes[];

  /**
   * TCPProxy holds TCP proxy information.
   *
   * @schema HttpProxySpec#tcpproxy
   */
  readonly tcpproxy?: HttpProxySpecTcpproxy;

  /**
   * Virtualhost appears at most once. If it is present, the object is considered to be a "root" HTTPProxy.
   *
   * @schema HttpProxySpec#virtualhost
   */
  readonly virtualhost?: HttpProxySpecVirtualhost;

}

/**
 * Converts an object of type 'HttpProxySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpec(obj: HttpProxySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'includes': obj.includes?.map(y => toJson_HttpProxySpecIncludes(y)),
    'ingressClassName': obj.ingressClassName,
    'routes': obj.routes?.map(y => toJson_HttpProxySpecRoutes(y)),
    'tcpproxy': toJson_HttpProxySpecTcpproxy(obj.tcpproxy),
    'virtualhost': toJson_HttpProxySpecVirtualhost(obj.virtualhost),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Include describes a set of policies that can be applied to an HTTPProxy in a namespace.
 *
 * @schema HttpProxySpecIncludes
 */
export interface HttpProxySpecIncludes {
  /**
   * Conditions are a set of rules that are applied to included HTTPProxies. In effect, they are added onto the Conditions of included HTTPProxy Route structs. When applied, they are merged using AND, with one exception: There can be only one Prefix MatchCondition per Conditions slice. More than one Prefix, or contradictory Conditions, will make the include invalid.
   *
   * @schema HttpProxySpecIncludes#conditions
   */
  readonly conditions?: HttpProxySpecIncludesConditions[];

  /**
   * Name of the HTTPProxy
   *
   * @schema HttpProxySpecIncludes#name
   */
  readonly name: string;

  /**
   * Namespace of the HTTPProxy to include. Defaults to the current namespace if not supplied.
   *
   * @default the current namespace if not supplied.
   * @schema HttpProxySpecIncludes#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'HttpProxySpecIncludes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecIncludes(obj: HttpProxySpecIncludes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_HttpProxySpecIncludesConditions(y)),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Route contains the set of routes for a virtual host.
 *
 * @schema HttpProxySpecRoutes
 */
export interface HttpProxySpecRoutes {
  /**
   * AuthPolicy updates the authorization policy that was set on the root HTTPProxy object for client requests that match this route.
   *
   * @schema HttpProxySpecRoutes#authPolicy
   */
  readonly authPolicy?: HttpProxySpecRoutesAuthPolicy;

  /**
   * Conditions are a set of rules that are applied to a Route. When applied, they are merged using AND, with one exception: There can be only one Prefix MatchCondition per Conditions slice. More than one Prefix, or contradictory Conditions, will make the route invalid.
   *
   * @schema HttpProxySpecRoutes#conditions
   */
  readonly conditions?: HttpProxySpecRoutesConditions[];

  /**
   * The policies for rewriting Set-Cookie header attributes. Note that rewritten cookie names must be unique in this list. Order rewrite policies are specified in does not matter.
   *
   * @schema HttpProxySpecRoutes#cookieRewritePolicies
   */
  readonly cookieRewritePolicies?: HttpProxySpecRoutesCookieRewritePolicies[];

  /**
   * DirectResponsePolicy returns an arbitrary HTTP response directly.
   *
   * @schema HttpProxySpecRoutes#directResponsePolicy
   */
  readonly directResponsePolicy?: HttpProxySpecRoutesDirectResponsePolicy;

  /**
   * Enables websocket support for the route.
   *
   * @schema HttpProxySpecRoutes#enableWebsockets
   */
  readonly enableWebsockets?: boolean;

  /**
   * The health check policy for this route.
   *
   * @schema HttpProxySpecRoutes#healthCheckPolicy
   */
  readonly healthCheckPolicy?: HttpProxySpecRoutesHealthCheckPolicy;

  /**
   * The load balancing policy for this route.
   *
   * @schema HttpProxySpecRoutes#loadBalancerPolicy
   */
  readonly loadBalancerPolicy?: HttpProxySpecRoutesLoadBalancerPolicy;

  /**
   * The policy for rewriting the path of the request URL after the request has been routed to a Service.
   *
   * @schema HttpProxySpecRoutes#pathRewritePolicy
   */
  readonly pathRewritePolicy?: HttpProxySpecRoutesPathRewritePolicy;

  /**
   * Allow this path to respond to insecure requests over HTTP which are normally not permitted when a `virtualhost.tls` block is present.
   *
   * @schema HttpProxySpecRoutes#permitInsecure
   */
  readonly permitInsecure?: boolean;

  /**
   * The policy for rate limiting on the route.
   *
   * @schema HttpProxySpecRoutes#rateLimitPolicy
   */
  readonly rateLimitPolicy?: HttpProxySpecRoutesRateLimitPolicy;

  /**
   * The policy for managing request headers during proxying.
   *
   * @schema HttpProxySpecRoutes#requestHeadersPolicy
   */
  readonly requestHeadersPolicy?: HttpProxySpecRoutesRequestHeadersPolicy;

  /**
   * RequestRedirectPolicy defines an HTTP redirection.
   *
   * @schema HttpProxySpecRoutes#requestRedirectPolicy
   */
  readonly requestRedirectPolicy?: HttpProxySpecRoutesRequestRedirectPolicy;

  /**
   * The policy for managing response headers during proxying. Rewriting the 'Host' header is not supported.
   *
   * @schema HttpProxySpecRoutes#responseHeadersPolicy
   */
  readonly responseHeadersPolicy?: HttpProxySpecRoutesResponseHeadersPolicy;

  /**
   * The retry policy for this route.
   *
   * @schema HttpProxySpecRoutes#retryPolicy
   */
  readonly retryPolicy?: HttpProxySpecRoutesRetryPolicy;

  /**
   * Services are the services to proxy traffic.
   *
   * @schema HttpProxySpecRoutes#services
   */
  readonly services?: HttpProxySpecRoutesServices[];

  /**
   * The timeout policy for this route.
   *
   * @schema HttpProxySpecRoutes#timeoutPolicy
   */
  readonly timeoutPolicy?: HttpProxySpecRoutesTimeoutPolicy;

}

/**
 * Converts an object of type 'HttpProxySpecRoutes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutes(obj: HttpProxySpecRoutes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authPolicy': toJson_HttpProxySpecRoutesAuthPolicy(obj.authPolicy),
    'conditions': obj.conditions?.map(y => toJson_HttpProxySpecRoutesConditions(y)),
    'cookieRewritePolicies': obj.cookieRewritePolicies?.map(y => toJson_HttpProxySpecRoutesCookieRewritePolicies(y)),
    'directResponsePolicy': toJson_HttpProxySpecRoutesDirectResponsePolicy(obj.directResponsePolicy),
    'enableWebsockets': obj.enableWebsockets,
    'healthCheckPolicy': toJson_HttpProxySpecRoutesHealthCheckPolicy(obj.healthCheckPolicy),
    'loadBalancerPolicy': toJson_HttpProxySpecRoutesLoadBalancerPolicy(obj.loadBalancerPolicy),
    'pathRewritePolicy': toJson_HttpProxySpecRoutesPathRewritePolicy(obj.pathRewritePolicy),
    'permitInsecure': obj.permitInsecure,
    'rateLimitPolicy': toJson_HttpProxySpecRoutesRateLimitPolicy(obj.rateLimitPolicy),
    'requestHeadersPolicy': toJson_HttpProxySpecRoutesRequestHeadersPolicy(obj.requestHeadersPolicy),
    'requestRedirectPolicy': toJson_HttpProxySpecRoutesRequestRedirectPolicy(obj.requestRedirectPolicy),
    'responseHeadersPolicy': toJson_HttpProxySpecRoutesResponseHeadersPolicy(obj.responseHeadersPolicy),
    'retryPolicy': toJson_HttpProxySpecRoutesRetryPolicy(obj.retryPolicy),
    'services': obj.services?.map(y => toJson_HttpProxySpecRoutesServices(y)),
    'timeoutPolicy': toJson_HttpProxySpecRoutesTimeoutPolicy(obj.timeoutPolicy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPProxy holds TCP proxy information.
 *
 * @schema HttpProxySpecTcpproxy
 */
export interface HttpProxySpecTcpproxy {
  /**
   * The health check policy for this tcp proxy
   *
   * @schema HttpProxySpecTcpproxy#healthCheckPolicy
   */
  readonly healthCheckPolicy?: HttpProxySpecTcpproxyHealthCheckPolicy;

  /**
   * Include specifies that this tcpproxy should be delegated to another HTTPProxy.
   *
   * @schema HttpProxySpecTcpproxy#include
   */
  readonly include?: HttpProxySpecTcpproxyInclude;

  /**
   * IncludesDeprecated allow for specific routing configuration to be appended to another HTTPProxy in another namespace.
   * Exists due to a mistake when developing HTTPProxy and the field was marked plural when it should have been singular. This field should stay to not break backwards compatibility to v1 users.
   *
   * @schema HttpProxySpecTcpproxy#includes
   */
  readonly includes?: HttpProxySpecTcpproxyIncludes;

  /**
   * The load balancing policy for the backend services. Note that the `Cookie` and `RequestHash` load balancing strategies cannot be used here.
   *
   * @schema HttpProxySpecTcpproxy#loadBalancerPolicy
   */
  readonly loadBalancerPolicy?: HttpProxySpecTcpproxyLoadBalancerPolicy;

  /**
   * Services are the services to proxy traffic
   *
   * @schema HttpProxySpecTcpproxy#services
   */
  readonly services?: HttpProxySpecTcpproxyServices[];

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxy(obj: HttpProxySpecTcpproxy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthCheckPolicy': toJson_HttpProxySpecTcpproxyHealthCheckPolicy(obj.healthCheckPolicy),
    'include': toJson_HttpProxySpecTcpproxyInclude(obj.include),
    'includes': toJson_HttpProxySpecTcpproxyIncludes(obj.includes),
    'loadBalancerPolicy': toJson_HttpProxySpecTcpproxyLoadBalancerPolicy(obj.loadBalancerPolicy),
    'services': obj.services?.map(y => toJson_HttpProxySpecTcpproxyServices(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Virtualhost appears at most once. If it is present, the object is considered to be a "root" HTTPProxy.
 *
 * @schema HttpProxySpecVirtualhost
 */
export interface HttpProxySpecVirtualhost {
  /**
   * This field configures an extension service to perform authorization for this virtual host. Authorization can only be configured on virtual hosts that have TLS enabled. If the TLS configuration requires client certificate validation, the client certificate is always included in the authentication check request.
   *
   * @schema HttpProxySpecVirtualhost#authorization
   */
  readonly authorization?: HttpProxySpecVirtualhostAuthorization;

  /**
   * Specifies the cross-origin policy to apply to the VirtualHost.
   *
   * @schema HttpProxySpecVirtualhost#corsPolicy
   */
  readonly corsPolicy?: HttpProxySpecVirtualhostCorsPolicy;

  /**
   * The fully qualified domain name of the root of the ingress tree all leaves of the DAG rooted at this object relate to the fqdn.
   *
   * @schema HttpProxySpecVirtualhost#fqdn
   */
  readonly fqdn: string;

  /**
   * The policy for rate limiting on the virtual host.
   *
   * @schema HttpProxySpecVirtualhost#rateLimitPolicy
   */
  readonly rateLimitPolicy?: HttpProxySpecVirtualhostRateLimitPolicy;

  /**
   * If present the fields describes TLS properties of the virtual host. The SNI names that will be matched on are described in fqdn, the tls.secretName secret must contain a certificate that itself contains a name that matches the FQDN.
   *
   * @schema HttpProxySpecVirtualhost#tls
   */
  readonly tls?: HttpProxySpecVirtualhostTls;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhost' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhost(obj: HttpProxySpecVirtualhost | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_HttpProxySpecVirtualhostAuthorization(obj.authorization),
    'corsPolicy': toJson_HttpProxySpecVirtualhostCorsPolicy(obj.corsPolicy),
    'fqdn': obj.fqdn,
    'rateLimitPolicy': toJson_HttpProxySpecVirtualhostRateLimitPolicy(obj.rateLimitPolicy),
    'tls': toJson_HttpProxySpecVirtualhostTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MatchCondition are a general holder for matching rules for HTTPProxies. One of Prefix or Header must be provided.
 *
 * @schema HttpProxySpecIncludesConditions
 */
export interface HttpProxySpecIncludesConditions {
  /**
   * Header specifies the header condition to match.
   *
   * @schema HttpProxySpecIncludesConditions#header
   */
  readonly header?: HttpProxySpecIncludesConditionsHeader;

  /**
   * Prefix defines a prefix match for a request.
   *
   * @schema HttpProxySpecIncludesConditions#prefix
   */
  readonly prefix?: string;

}

/**
 * Converts an object of type 'HttpProxySpecIncludesConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecIncludesConditions(obj: HttpProxySpecIncludesConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'header': toJson_HttpProxySpecIncludesConditionsHeader(obj.header),
    'prefix': obj.prefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AuthPolicy updates the authorization policy that was set on the root HTTPProxy object for client requests that match this route.
 *
 * @schema HttpProxySpecRoutesAuthPolicy
 */
export interface HttpProxySpecRoutesAuthPolicy {
  /**
   * Context is a set of key/value pairs that are sent to the authentication server in the check request. If a context is provided at an enclosing scope, the entries are merged such that the inner scope overrides matching keys from the outer scope.
   *
   * @schema HttpProxySpecRoutesAuthPolicy#context
   */
  readonly context?: { [key: string]: string };

  /**
   * When true, this field disables client request authentication for the scope of the policy.
   *
   * @schema HttpProxySpecRoutesAuthPolicy#disabled
   */
  readonly disabled?: boolean;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesAuthPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesAuthPolicy(obj: HttpProxySpecRoutesAuthPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': ((obj.context) === undefined) ? undefined : (Object.entries(obj.context).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'disabled': obj.disabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MatchCondition are a general holder for matching rules for HTTPProxies. One of Prefix or Header must be provided.
 *
 * @schema HttpProxySpecRoutesConditions
 */
export interface HttpProxySpecRoutesConditions {
  /**
   * Header specifies the header condition to match.
   *
   * @schema HttpProxySpecRoutesConditions#header
   */
  readonly header?: HttpProxySpecRoutesConditionsHeader;

  /**
   * Prefix defines a prefix match for a request.
   *
   * @schema HttpProxySpecRoutesConditions#prefix
   */
  readonly prefix?: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesConditions(obj: HttpProxySpecRoutesConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'header': toJson_HttpProxySpecRoutesConditionsHeader(obj.header),
    'prefix': obj.prefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema HttpProxySpecRoutesCookieRewritePolicies
 */
export interface HttpProxySpecRoutesCookieRewritePolicies {
  /**
   * DomainRewrite enables rewriting the Set-Cookie Domain element. If not set, Domain will not be rewritten.
   *
   * @schema HttpProxySpecRoutesCookieRewritePolicies#domainRewrite
   */
  readonly domainRewrite?: HttpProxySpecRoutesCookieRewritePoliciesDomainRewrite;

  /**
   * Name is the name of the cookie for which attributes will be rewritten.
   *
   * @schema HttpProxySpecRoutesCookieRewritePolicies#name
   */
  readonly name: string;

  /**
   * PathRewrite enables rewriting the Set-Cookie Path element. If not set, Path will not be rewritten.
   *
   * @schema HttpProxySpecRoutesCookieRewritePolicies#pathRewrite
   */
  readonly pathRewrite?: HttpProxySpecRoutesCookieRewritePoliciesPathRewrite;

  /**
   * SameSite enables rewriting the Set-Cookie SameSite element. If not set, SameSite attribute will not be rewritten.
   *
   * @schema HttpProxySpecRoutesCookieRewritePolicies#sameSite
   */
  readonly sameSite?: HttpProxySpecRoutesCookieRewritePoliciesSameSite;

  /**
   * Secure enables rewriting the Set-Cookie Secure element. If not set, Secure attribute will not be rewritten.
   *
   * @schema HttpProxySpecRoutesCookieRewritePolicies#secure
   */
  readonly secure?: boolean;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesCookieRewritePolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesCookieRewritePolicies(obj: HttpProxySpecRoutesCookieRewritePolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domainRewrite': toJson_HttpProxySpecRoutesCookieRewritePoliciesDomainRewrite(obj.domainRewrite),
    'name': obj.name,
    'pathRewrite': toJson_HttpProxySpecRoutesCookieRewritePoliciesPathRewrite(obj.pathRewrite),
    'sameSite': obj.sameSite,
    'secure': obj.secure,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DirectResponsePolicy returns an arbitrary HTTP response directly.
 *
 * @schema HttpProxySpecRoutesDirectResponsePolicy
 */
export interface HttpProxySpecRoutesDirectResponsePolicy {
  /**
   * Body is the content of the response body. If this setting is omitted, no body is included in the generated response.
   * Note: Body is not recommended to set too long otherwise it can have significant resource usage impacts.
   *
   * @schema HttpProxySpecRoutesDirectResponsePolicy#body
   */
  readonly body?: string;

  /**
   * StatusCode is the HTTP response status to be returned.
   *
   * @schema HttpProxySpecRoutesDirectResponsePolicy#statusCode
   */
  readonly statusCode: number;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesDirectResponsePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesDirectResponsePolicy(obj: HttpProxySpecRoutesDirectResponsePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'body': obj.body,
    'statusCode': obj.statusCode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The health check policy for this route.
 *
 * @schema HttpProxySpecRoutesHealthCheckPolicy
 */
export interface HttpProxySpecRoutesHealthCheckPolicy {
  /**
   * The number of healthy health checks required before a host is marked healthy
   *
   * @schema HttpProxySpecRoutesHealthCheckPolicy#healthyThresholdCount
   */
  readonly healthyThresholdCount?: number;

  /**
   * The value of the host header in the HTTP health check request. If left empty (default value), the name "contour-envoy-healthcheck" will be used.
   *
   * @schema HttpProxySpecRoutesHealthCheckPolicy#host
   */
  readonly host?: string;

  /**
   * The interval (seconds) between health checks
   *
   * @schema HttpProxySpecRoutesHealthCheckPolicy#intervalSeconds
   */
  readonly intervalSeconds?: number;

  /**
   * HTTP endpoint used to perform health checks on upstream service
   *
   * @schema HttpProxySpecRoutesHealthCheckPolicy#path
   */
  readonly path: string;

  /**
   * The time to wait (seconds) for a health check response
   *
   * @schema HttpProxySpecRoutesHealthCheckPolicy#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

  /**
   * The number of unhealthy health checks required before a host is marked unhealthy
   *
   * @schema HttpProxySpecRoutesHealthCheckPolicy#unhealthyThresholdCount
   */
  readonly unhealthyThresholdCount?: number;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesHealthCheckPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesHealthCheckPolicy(obj: HttpProxySpecRoutesHealthCheckPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthyThresholdCount': obj.healthyThresholdCount,
    'host': obj.host,
    'intervalSeconds': obj.intervalSeconds,
    'path': obj.path,
    'timeoutSeconds': obj.timeoutSeconds,
    'unhealthyThresholdCount': obj.unhealthyThresholdCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The load balancing policy for this route.
 *
 * @schema HttpProxySpecRoutesLoadBalancerPolicy
 */
export interface HttpProxySpecRoutesLoadBalancerPolicy {
  /**
   * RequestHashPolicies contains a list of hash policies to apply when the `RequestHash` load balancing strategy is chosen. If an element of the supplied list of hash policies is invalid, it will be ignored. If the list of hash policies is empty after validation, the load balancing strategy will fall back the the default `RoundRobin`.
   *
   * @schema HttpProxySpecRoutesLoadBalancerPolicy#requestHashPolicies
   */
  readonly requestHashPolicies?: HttpProxySpecRoutesLoadBalancerPolicyRequestHashPolicies[];

  /**
   * Strategy specifies the policy used to balance requests across the pool of backend pods. Valid policy names are `Random`, `RoundRobin`, `WeightedLeastRequest`, `Cookie`, and `RequestHash`. If an unknown strategy name is specified or no policy is supplied, the default `RoundRobin` policy is used.
   *
   * @schema HttpProxySpecRoutesLoadBalancerPolicy#strategy
   */
  readonly strategy?: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesLoadBalancerPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesLoadBalancerPolicy(obj: HttpProxySpecRoutesLoadBalancerPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'requestHashPolicies': obj.requestHashPolicies?.map(y => toJson_HttpProxySpecRoutesLoadBalancerPolicyRequestHashPolicies(y)),
    'strategy': obj.strategy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The policy for rewriting the path of the request URL after the request has been routed to a Service.
 *
 * @schema HttpProxySpecRoutesPathRewritePolicy
 */
export interface HttpProxySpecRoutesPathRewritePolicy {
  /**
   * ReplacePrefix describes how the path prefix should be replaced.
   *
   * @schema HttpProxySpecRoutesPathRewritePolicy#replacePrefix
   */
  readonly replacePrefix?: HttpProxySpecRoutesPathRewritePolicyReplacePrefix[];

}

/**
 * Converts an object of type 'HttpProxySpecRoutesPathRewritePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesPathRewritePolicy(obj: HttpProxySpecRoutesPathRewritePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'replacePrefix': obj.replacePrefix?.map(y => toJson_HttpProxySpecRoutesPathRewritePolicyReplacePrefix(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The policy for rate limiting on the route.
 *
 * @schema HttpProxySpecRoutesRateLimitPolicy
 */
export interface HttpProxySpecRoutesRateLimitPolicy {
  /**
   * Global defines global rate limiting parameters, i.e. parameters defining descriptors that are sent to an external rate limit service (RLS) for a rate limit decision on each request.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicy#global
   */
  readonly global?: HttpProxySpecRoutesRateLimitPolicyGlobal;

  /**
   * Local defines local rate limiting parameters, i.e. parameters for rate limiting that occurs within each Envoy pod as requests are handled.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicy#local
   */
  readonly local?: HttpProxySpecRoutesRateLimitPolicyLocal;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesRateLimitPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesRateLimitPolicy(obj: HttpProxySpecRoutesRateLimitPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'global': toJson_HttpProxySpecRoutesRateLimitPolicyGlobal(obj.global),
    'local': toJson_HttpProxySpecRoutesRateLimitPolicyLocal(obj.local),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The policy for managing request headers during proxying.
 *
 * @schema HttpProxySpecRoutesRequestHeadersPolicy
 */
export interface HttpProxySpecRoutesRequestHeadersPolicy {
  /**
   * Remove specifies a list of HTTP header names to remove.
   *
   * @schema HttpProxySpecRoutesRequestHeadersPolicy#remove
   */
  readonly remove?: string[];

  /**
   * Set specifies a list of HTTP header values that will be set in the HTTP header. If the header does not exist it will be added, otherwise it will be overwritten with the new value.
   *
   * @schema HttpProxySpecRoutesRequestHeadersPolicy#set
   */
  readonly set?: HttpProxySpecRoutesRequestHeadersPolicySet[];

}

/**
 * Converts an object of type 'HttpProxySpecRoutesRequestHeadersPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesRequestHeadersPolicy(obj: HttpProxySpecRoutesRequestHeadersPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'remove': obj.remove?.map(y => y),
    'set': obj.set?.map(y => toJson_HttpProxySpecRoutesRequestHeadersPolicySet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RequestRedirectPolicy defines an HTTP redirection.
 *
 * @schema HttpProxySpecRoutesRequestRedirectPolicy
 */
export interface HttpProxySpecRoutesRequestRedirectPolicy {
  /**
   * Hostname is the precise hostname to be used in the value of the `Location` header in the response. When empty, the hostname of the request is used. No wildcards are allowed.
   *
   * @schema HttpProxySpecRoutesRequestRedirectPolicy#hostname
   */
  readonly hostname?: string;

  /**
   * Path allows for redirection to a different path from the original on the request. The path must start with a leading slash.
   * Note: Only one of Path or Prefix can be defined.
   *
   * @schema HttpProxySpecRoutesRequestRedirectPolicy#path
   */
  readonly path?: string;

  /**
   * Port is the port to be used in the value of the `Location` header in the response. When empty, port (if specified) of the request is used.
   *
   * @schema HttpProxySpecRoutesRequestRedirectPolicy#port
   */
  readonly port?: number;

  /**
   * Prefix defines the value to swap the matched prefix or path with. The prefix must start with a leading slash.
   * Note: Only one of Path or Prefix can be defined.
   *
   * @schema HttpProxySpecRoutesRequestRedirectPolicy#prefix
   */
  readonly prefix?: string;

  /**
   * Scheme is the scheme to be used in the value of the `Location` header in the response. When empty, the scheme of the request is used.
   *
   * @schema HttpProxySpecRoutesRequestRedirectPolicy#scheme
   */
  readonly scheme?: HttpProxySpecRoutesRequestRedirectPolicyScheme;

  /**
   * StatusCode is the HTTP status code to be used in response.
   *
   * @schema HttpProxySpecRoutesRequestRedirectPolicy#statusCode
   */
  readonly statusCode?: number;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesRequestRedirectPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesRequestRedirectPolicy(obj: HttpProxySpecRoutesRequestRedirectPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostname': obj.hostname,
    'path': obj.path,
    'port': obj.port,
    'prefix': obj.prefix,
    'scheme': obj.scheme,
    'statusCode': obj.statusCode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The policy for managing response headers during proxying. Rewriting the 'Host' header is not supported.
 *
 * @schema HttpProxySpecRoutesResponseHeadersPolicy
 */
export interface HttpProxySpecRoutesResponseHeadersPolicy {
  /**
   * Remove specifies a list of HTTP header names to remove.
   *
   * @schema HttpProxySpecRoutesResponseHeadersPolicy#remove
   */
  readonly remove?: string[];

  /**
   * Set specifies a list of HTTP header values that will be set in the HTTP header. If the header does not exist it will be added, otherwise it will be overwritten with the new value.
   *
   * @schema HttpProxySpecRoutesResponseHeadersPolicy#set
   */
  readonly set?: HttpProxySpecRoutesResponseHeadersPolicySet[];

}

/**
 * Converts an object of type 'HttpProxySpecRoutesResponseHeadersPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesResponseHeadersPolicy(obj: HttpProxySpecRoutesResponseHeadersPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'remove': obj.remove?.map(y => y),
    'set': obj.set?.map(y => toJson_HttpProxySpecRoutesResponseHeadersPolicySet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The retry policy for this route.
 *
 * @schema HttpProxySpecRoutesRetryPolicy
 */
export interface HttpProxySpecRoutesRetryPolicy {
  /**
   * NumRetries is maximum allowed number of retries. If set to -1, then retries are disabled. If set to 0 or not supplied, the value is set to the Envoy default of 1.
   *
   * @schema HttpProxySpecRoutesRetryPolicy#count
   */
  readonly count?: number;

  /**
   * PerTryTimeout specifies the timeout per retry attempt. Ignored if NumRetries is not supplied.
   *
   * @schema HttpProxySpecRoutesRetryPolicy#perTryTimeout
   */
  readonly perTryTimeout?: string;

  /**
   * RetriableStatusCodes specifies the HTTP status codes that should be retried.
   * This field is only respected when you include `retriable-status-codes` in the `RetryOn` field.
   *
   * @schema HttpProxySpecRoutesRetryPolicy#retriableStatusCodes
   */
  readonly retriableStatusCodes?: number[];

  /**
   * RetryOn specifies the conditions on which to retry a request.
   * Supported [HTTP conditions](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-on):
   * - `5xx` - `gateway-error` - `reset` - `connect-failure` - `retriable-4xx` - `refused-stream` - `retriable-status-codes` - `retriable-headers`
   * Supported [gRPC conditions](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-grpc-on):
   * - `cancelled` - `deadline-exceeded` - `internal` - `resource-exhausted` - `unavailable`
   *
   * @schema HttpProxySpecRoutesRetryPolicy#retryOn
   */
  readonly retryOn?: HttpProxySpecRoutesRetryPolicyRetryOn[];

}

/**
 * Converts an object of type 'HttpProxySpecRoutesRetryPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesRetryPolicy(obj: HttpProxySpecRoutesRetryPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'perTryTimeout': obj.perTryTimeout,
    'retriableStatusCodes': obj.retriableStatusCodes?.map(y => y),
    'retryOn': obj.retryOn?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Service defines an Kubernetes Service to proxy traffic.
 *
 * @schema HttpProxySpecRoutesServices
 */
export interface HttpProxySpecRoutesServices {
  /**
   * The policies for rewriting Set-Cookie header attributes.
   *
   * @schema HttpProxySpecRoutesServices#cookieRewritePolicies
   */
  readonly cookieRewritePolicies?: HttpProxySpecRoutesServicesCookieRewritePolicies[];

  /**
   * If Mirror is true the Service will receive a read only mirror of the traffic for this route.
   *
   * @schema HttpProxySpecRoutesServices#mirror
   */
  readonly mirror?: boolean;

  /**
   * Name is the name of Kubernetes service to proxy traffic. Names defined here will be used to look up corresponding endpoints which contain the ips to route.
   *
   * @schema HttpProxySpecRoutesServices#name
   */
  readonly name: string;

  /**
   * Port (defined as Integer) to proxy traffic to since a service can have multiple defined.
   *
   * @schema HttpProxySpecRoutesServices#port
   */
  readonly port: number;

  /**
   * Protocol may be used to specify (or override) the protocol used to reach this Service. Values may be tls, h2, h2c. If omitted, protocol-selection falls back on Service annotations.
   *
   * @schema HttpProxySpecRoutesServices#protocol
   */
  readonly protocol?: HttpProxySpecRoutesServicesProtocol;

  /**
   * The policy for managing request headers during proxying. Rewriting the 'Host' header is not supported.
   *
   * @schema HttpProxySpecRoutesServices#requestHeadersPolicy
   */
  readonly requestHeadersPolicy?: HttpProxySpecRoutesServicesRequestHeadersPolicy;

  /**
   * The policy for managing response headers during proxying. Rewriting the 'Host' header is not supported.
   *
   * @schema HttpProxySpecRoutesServices#responseHeadersPolicy
   */
  readonly responseHeadersPolicy?: HttpProxySpecRoutesServicesResponseHeadersPolicy;

  /**
   * UpstreamValidation defines how to verify the backend service's certificate
   *
   * @schema HttpProxySpecRoutesServices#validation
   */
  readonly validation?: HttpProxySpecRoutesServicesValidation;

  /**
   * Weight defines percentage of traffic to balance traffic
   *
   * @schema HttpProxySpecRoutesServices#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesServices(obj: HttpProxySpecRoutesServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookieRewritePolicies': obj.cookieRewritePolicies?.map(y => toJson_HttpProxySpecRoutesServicesCookieRewritePolicies(y)),
    'mirror': obj.mirror,
    'name': obj.name,
    'port': obj.port,
    'protocol': obj.protocol,
    'requestHeadersPolicy': toJson_HttpProxySpecRoutesServicesRequestHeadersPolicy(obj.requestHeadersPolicy),
    'responseHeadersPolicy': toJson_HttpProxySpecRoutesServicesResponseHeadersPolicy(obj.responseHeadersPolicy),
    'validation': toJson_HttpProxySpecRoutesServicesValidation(obj.validation),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The timeout policy for this route.
 *
 * @schema HttpProxySpecRoutesTimeoutPolicy
 */
export interface HttpProxySpecRoutesTimeoutPolicy {
  /**
   * Timeout for how long the proxy should wait while there is no activity during single request/response (for HTTP/1.1) or stream (for HTTP/2). Timeout will not trigger while HTTP/1.1 connection is idle between two consecutive requests. If not specified, there is no per-route idle timeout, though a connection manager-wide stream_idle_timeout default of 5m still applies.
   *
   * @schema HttpProxySpecRoutesTimeoutPolicy#idle
   */
  readonly idle?: string;

  /**
   * Timeout for how long connection from the proxy to the upstream service is kept when there are no active requests. If not supplied, Envoy's default value of 1h applies.
   *
   * @schema HttpProxySpecRoutesTimeoutPolicy#idleConnection
   */
  readonly idleConnection?: string;

  /**
   * Timeout for receiving a response from the server after processing a request from client. If not supplied, Envoy's default value of 15s applies.
   *
   * @schema HttpProxySpecRoutesTimeoutPolicy#response
   */
  readonly response?: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesTimeoutPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesTimeoutPolicy(obj: HttpProxySpecRoutesTimeoutPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idle': obj.idle,
    'idleConnection': obj.idleConnection,
    'response': obj.response,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The health check policy for this tcp proxy
 *
 * @schema HttpProxySpecTcpproxyHealthCheckPolicy
 */
export interface HttpProxySpecTcpproxyHealthCheckPolicy {
  /**
   * The number of healthy health checks required before a host is marked healthy
   *
   * @schema HttpProxySpecTcpproxyHealthCheckPolicy#healthyThresholdCount
   */
  readonly healthyThresholdCount?: number;

  /**
   * The interval (seconds) between health checks
   *
   * @schema HttpProxySpecTcpproxyHealthCheckPolicy#intervalSeconds
   */
  readonly intervalSeconds?: number;

  /**
   * The time to wait (seconds) for a health check response
   *
   * @schema HttpProxySpecTcpproxyHealthCheckPolicy#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

  /**
   * The number of unhealthy health checks required before a host is marked unhealthy
   *
   * @schema HttpProxySpecTcpproxyHealthCheckPolicy#unhealthyThresholdCount
   */
  readonly unhealthyThresholdCount?: number;

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyHealthCheckPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyHealthCheckPolicy(obj: HttpProxySpecTcpproxyHealthCheckPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthyThresholdCount': obj.healthyThresholdCount,
    'intervalSeconds': obj.intervalSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
    'unhealthyThresholdCount': obj.unhealthyThresholdCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Include specifies that this tcpproxy should be delegated to another HTTPProxy.
 *
 * @schema HttpProxySpecTcpproxyInclude
 */
export interface HttpProxySpecTcpproxyInclude {
  /**
   * Name of the child HTTPProxy
   *
   * @schema HttpProxySpecTcpproxyInclude#name
   */
  readonly name: string;

  /**
   * Namespace of the HTTPProxy to include. Defaults to the current namespace if not supplied.
   *
   * @default the current namespace if not supplied.
   * @schema HttpProxySpecTcpproxyInclude#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyInclude' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyInclude(obj: HttpProxySpecTcpproxyInclude | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IncludesDeprecated allow for specific routing configuration to be appended to another HTTPProxy in another namespace.
 * Exists due to a mistake when developing HTTPProxy and the field was marked plural when it should have been singular. This field should stay to not break backwards compatibility to v1 users.
 *
 * @schema HttpProxySpecTcpproxyIncludes
 */
export interface HttpProxySpecTcpproxyIncludes {
  /**
   * Name of the child HTTPProxy
   *
   * @schema HttpProxySpecTcpproxyIncludes#name
   */
  readonly name: string;

  /**
   * Namespace of the HTTPProxy to include. Defaults to the current namespace if not supplied.
   *
   * @default the current namespace if not supplied.
   * @schema HttpProxySpecTcpproxyIncludes#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyIncludes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyIncludes(obj: HttpProxySpecTcpproxyIncludes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The load balancing policy for the backend services. Note that the `Cookie` and `RequestHash` load balancing strategies cannot be used here.
 *
 * @schema HttpProxySpecTcpproxyLoadBalancerPolicy
 */
export interface HttpProxySpecTcpproxyLoadBalancerPolicy {
  /**
   * RequestHashPolicies contains a list of hash policies to apply when the `RequestHash` load balancing strategy is chosen. If an element of the supplied list of hash policies is invalid, it will be ignored. If the list of hash policies is empty after validation, the load balancing strategy will fall back the the default `RoundRobin`.
   *
   * @schema HttpProxySpecTcpproxyLoadBalancerPolicy#requestHashPolicies
   */
  readonly requestHashPolicies?: HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPolicies[];

  /**
   * Strategy specifies the policy used to balance requests across the pool of backend pods. Valid policy names are `Random`, `RoundRobin`, `WeightedLeastRequest`, `Cookie`, and `RequestHash`. If an unknown strategy name is specified or no policy is supplied, the default `RoundRobin` policy is used.
   *
   * @schema HttpProxySpecTcpproxyLoadBalancerPolicy#strategy
   */
  readonly strategy?: string;

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyLoadBalancerPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyLoadBalancerPolicy(obj: HttpProxySpecTcpproxyLoadBalancerPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'requestHashPolicies': obj.requestHashPolicies?.map(y => toJson_HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPolicies(y)),
    'strategy': obj.strategy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Service defines an Kubernetes Service to proxy traffic.
 *
 * @schema HttpProxySpecTcpproxyServices
 */
export interface HttpProxySpecTcpproxyServices {
  /**
   * The policies for rewriting Set-Cookie header attributes.
   *
   * @schema HttpProxySpecTcpproxyServices#cookieRewritePolicies
   */
  readonly cookieRewritePolicies?: HttpProxySpecTcpproxyServicesCookieRewritePolicies[];

  /**
   * If Mirror is true the Service will receive a read only mirror of the traffic for this route.
   *
   * @schema HttpProxySpecTcpproxyServices#mirror
   */
  readonly mirror?: boolean;

  /**
   * Name is the name of Kubernetes service to proxy traffic. Names defined here will be used to look up corresponding endpoints which contain the ips to route.
   *
   * @schema HttpProxySpecTcpproxyServices#name
   */
  readonly name: string;

  /**
   * Port (defined as Integer) to proxy traffic to since a service can have multiple defined.
   *
   * @schema HttpProxySpecTcpproxyServices#port
   */
  readonly port: number;

  /**
   * Protocol may be used to specify (or override) the protocol used to reach this Service. Values may be tls, h2, h2c. If omitted, protocol-selection falls back on Service annotations.
   *
   * @schema HttpProxySpecTcpproxyServices#protocol
   */
  readonly protocol?: HttpProxySpecTcpproxyServicesProtocol;

  /**
   * The policy for managing request headers during proxying. Rewriting the 'Host' header is not supported.
   *
   * @schema HttpProxySpecTcpproxyServices#requestHeadersPolicy
   */
  readonly requestHeadersPolicy?: HttpProxySpecTcpproxyServicesRequestHeadersPolicy;

  /**
   * The policy for managing response headers during proxying. Rewriting the 'Host' header is not supported.
   *
   * @schema HttpProxySpecTcpproxyServices#responseHeadersPolicy
   */
  readonly responseHeadersPolicy?: HttpProxySpecTcpproxyServicesResponseHeadersPolicy;

  /**
   * UpstreamValidation defines how to verify the backend service's certificate
   *
   * @schema HttpProxySpecTcpproxyServices#validation
   */
  readonly validation?: HttpProxySpecTcpproxyServicesValidation;

  /**
   * Weight defines percentage of traffic to balance traffic
   *
   * @schema HttpProxySpecTcpproxyServices#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyServices(obj: HttpProxySpecTcpproxyServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookieRewritePolicies': obj.cookieRewritePolicies?.map(y => toJson_HttpProxySpecTcpproxyServicesCookieRewritePolicies(y)),
    'mirror': obj.mirror,
    'name': obj.name,
    'port': obj.port,
    'protocol': obj.protocol,
    'requestHeadersPolicy': toJson_HttpProxySpecTcpproxyServicesRequestHeadersPolicy(obj.requestHeadersPolicy),
    'responseHeadersPolicy': toJson_HttpProxySpecTcpproxyServicesResponseHeadersPolicy(obj.responseHeadersPolicy),
    'validation': toJson_HttpProxySpecTcpproxyServicesValidation(obj.validation),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * This field configures an extension service to perform authorization for this virtual host. Authorization can only be configured on virtual hosts that have TLS enabled. If the TLS configuration requires client certificate validation, the client certificate is always included in the authentication check request.
 *
 * @schema HttpProxySpecVirtualhostAuthorization
 */
export interface HttpProxySpecVirtualhostAuthorization {
  /**
   * AuthPolicy sets a default authorization policy for client requests. This policy will be used unless overridden by individual routes.
   *
   * @schema HttpProxySpecVirtualhostAuthorization#authPolicy
   */
  readonly authPolicy?: HttpProxySpecVirtualhostAuthorizationAuthPolicy;

  /**
   * ExtensionServiceRef specifies the extension resource that will authorize client requests.
   *
   * @schema HttpProxySpecVirtualhostAuthorization#extensionRef
   */
  readonly extensionRef: HttpProxySpecVirtualhostAuthorizationExtensionRef;

  /**
   * If FailOpen is true, the client request is forwarded to the upstream service even if the authorization server fails to respond. This field should not be set in most cases. It is intended for use only while migrating applications from internal authorization to Contour external authorization.
   *
   * @schema HttpProxySpecVirtualhostAuthorization#failOpen
   */
  readonly failOpen?: boolean;

  /**
   * ResponseTimeout configures maximum time to wait for a check response from the authorization server. Timeout durations are expressed in the Go [Duration format](https://godoc.org/time#ParseDuration). Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h". The string "infinity" is also a valid input and specifies no timeout.
   *
   * @schema HttpProxySpecVirtualhostAuthorization#responseTimeout
   */
  readonly responseTimeout?: string;

  /**
   * WithRequestBody specifies configuration for sending the client request's body to authorization server.
   *
   * @schema HttpProxySpecVirtualhostAuthorization#withRequestBody
   */
  readonly withRequestBody?: HttpProxySpecVirtualhostAuthorizationWithRequestBody;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostAuthorization(obj: HttpProxySpecVirtualhostAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authPolicy': toJson_HttpProxySpecVirtualhostAuthorizationAuthPolicy(obj.authPolicy),
    'extensionRef': toJson_HttpProxySpecVirtualhostAuthorizationExtensionRef(obj.extensionRef),
    'failOpen': obj.failOpen,
    'responseTimeout': obj.responseTimeout,
    'withRequestBody': toJson_HttpProxySpecVirtualhostAuthorizationWithRequestBody(obj.withRequestBody),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the cross-origin policy to apply to the VirtualHost.
 *
 * @schema HttpProxySpecVirtualhostCorsPolicy
 */
export interface HttpProxySpecVirtualhostCorsPolicy {
  /**
   * Specifies whether the resource allows credentials.
   *
   * @schema HttpProxySpecVirtualhostCorsPolicy#allowCredentials
   */
  readonly allowCredentials?: boolean;

  /**
   * AllowHeaders specifies the content for the *access-control-allow-headers* header.
   *
   * @schema HttpProxySpecVirtualhostCorsPolicy#allowHeaders
   */
  readonly allowHeaders?: string[];

  /**
   * AllowMethods specifies the content for the *access-control-allow-methods* header.
   *
   * @schema HttpProxySpecVirtualhostCorsPolicy#allowMethods
   */
  readonly allowMethods: string[];

  /**
   * AllowOrigin specifies the origins that will be allowed to do CORS requests. "*" means allow any origin.
   *
   * @schema HttpProxySpecVirtualhostCorsPolicy#allowOrigin
   */
  readonly allowOrigin: string[];

  /**
   * ExposeHeaders Specifies the content for the *access-control-expose-headers* header.
   *
   * @schema HttpProxySpecVirtualhostCorsPolicy#exposeHeaders
   */
  readonly exposeHeaders?: string[];

  /**
   * MaxAge indicates for how long the results of a preflight request can be cached. MaxAge durations are expressed in the Go [Duration format](https://godoc.org/time#ParseDuration). Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h". Only positive values are allowed while 0 disables the cache requiring a preflight OPTIONS check for all cross-origin requests.
   *
   * @schema HttpProxySpecVirtualhostCorsPolicy#maxAge
   */
  readonly maxAge?: string;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostCorsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostCorsPolicy(obj: HttpProxySpecVirtualhostCorsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowCredentials': obj.allowCredentials,
    'allowHeaders': obj.allowHeaders?.map(y => y),
    'allowMethods': obj.allowMethods?.map(y => y),
    'allowOrigin': obj.allowOrigin?.map(y => y),
    'exposeHeaders': obj.exposeHeaders?.map(y => y),
    'maxAge': obj.maxAge,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The policy for rate limiting on the virtual host.
 *
 * @schema HttpProxySpecVirtualhostRateLimitPolicy
 */
export interface HttpProxySpecVirtualhostRateLimitPolicy {
  /**
   * Global defines global rate limiting parameters, i.e. parameters defining descriptors that are sent to an external rate limit service (RLS) for a rate limit decision on each request.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicy#global
   */
  readonly global?: HttpProxySpecVirtualhostRateLimitPolicyGlobal;

  /**
   * Local defines local rate limiting parameters, i.e. parameters for rate limiting that occurs within each Envoy pod as requests are handled.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicy#local
   */
  readonly local?: HttpProxySpecVirtualhostRateLimitPolicyLocal;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostRateLimitPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostRateLimitPolicy(obj: HttpProxySpecVirtualhostRateLimitPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'global': toJson_HttpProxySpecVirtualhostRateLimitPolicyGlobal(obj.global),
    'local': toJson_HttpProxySpecVirtualhostRateLimitPolicyLocal(obj.local),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If present the fields describes TLS properties of the virtual host. The SNI names that will be matched on are described in fqdn, the tls.secretName secret must contain a certificate that itself contains a name that matches the FQDN.
 *
 * @schema HttpProxySpecVirtualhostTls
 */
export interface HttpProxySpecVirtualhostTls {
  /**
   * ClientValidation defines how to verify the client certificate when an external client establishes a TLS connection to Envoy.
   * This setting:
   * 1. Enables TLS client certificate validation. 2. Specifies how the client certificate will be validated (i.e.    validation required or skipped).
   * Note: Setting client certificate validation to be skipped should be only used in conjunction with an external authorization server that performs client validation as Contour will ensure client certificates are passed along.
   *
   * @schema HttpProxySpecVirtualhostTls#clientValidation
   */
  readonly clientValidation?: HttpProxySpecVirtualhostTlsClientValidation;

  /**
   * EnableFallbackCertificate defines if the vhost should allow a default certificate to be applied which handles all requests which don't match the SNI defined in this vhost.
   *
   * @schema HttpProxySpecVirtualhostTls#enableFallbackCertificate
   */
  readonly enableFallbackCertificate?: boolean;

  /**
   * MinimumProtocolVersion is the minimum TLS version this vhost should negotiate. Valid options are `1.2` (default) and `1.3`. Any other value defaults to TLS 1.2.
   *
   * @schema HttpProxySpecVirtualhostTls#minimumProtocolVersion
   */
  readonly minimumProtocolVersion?: string;

  /**
   * Passthrough defines whether the encrypted TLS handshake will be passed through to the backing cluster. Either Passthrough or SecretName must be specified, but not both.
   *
   * @schema HttpProxySpecVirtualhostTls#passthrough
   */
  readonly passthrough?: boolean;

  /**
   * SecretName is the name of a TLS secret in the current namespace. Either SecretName or Passthrough must be specified, but not both. If specified, the named secret must contain a matching certificate for the virtual host's FQDN.
   *
   * @schema HttpProxySpecVirtualhostTls#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostTls(obj: HttpProxySpecVirtualhostTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientValidation': toJson_HttpProxySpecVirtualhostTlsClientValidation(obj.clientValidation),
    'enableFallbackCertificate': obj.enableFallbackCertificate,
    'minimumProtocolVersion': obj.minimumProtocolVersion,
    'passthrough': obj.passthrough,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Header specifies the header condition to match.
 *
 * @schema HttpProxySpecIncludesConditionsHeader
 */
export interface HttpProxySpecIncludesConditionsHeader {
  /**
   * Contains specifies a substring that must be present in the header value.
   *
   * @schema HttpProxySpecIncludesConditionsHeader#contains
   */
  readonly contains?: string;

  /**
   * Exact specifies a string that the header value must be equal to.
   *
   * @schema HttpProxySpecIncludesConditionsHeader#exact
   */
  readonly exact?: string;

  /**
   * Name is the name of the header to match against. Name is required. Header names are case insensitive.
   *
   * @schema HttpProxySpecIncludesConditionsHeader#name
   */
  readonly name: string;

  /**
   * NotContains specifies a substring that must not be present in the header value.
   *
   * @schema HttpProxySpecIncludesConditionsHeader#notcontains
   */
  readonly notcontains?: string;

  /**
   * NoExact specifies a string that the header value must not be equal to. The condition is true if the header has any other value.
   *
   * @schema HttpProxySpecIncludesConditionsHeader#notexact
   */
  readonly notexact?: string;

  /**
   * NotPresent specifies that condition is true when the named header is not present. Note that setting NotPresent to false does not make the condition true if the named header is present.
   *
   * @schema HttpProxySpecIncludesConditionsHeader#notpresent
   */
  readonly notpresent?: boolean;

  /**
   * Present specifies that condition is true when the named header is present, regardless of its value. Note that setting Present to false does not make the condition true if the named header is absent.
   *
   * @schema HttpProxySpecIncludesConditionsHeader#present
   */
  readonly present?: boolean;

}

/**
 * Converts an object of type 'HttpProxySpecIncludesConditionsHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecIncludesConditionsHeader(obj: HttpProxySpecIncludesConditionsHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contains': obj.contains,
    'exact': obj.exact,
    'name': obj.name,
    'notcontains': obj.notcontains,
    'notexact': obj.notexact,
    'notpresent': obj.notpresent,
    'present': obj.present,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Header specifies the header condition to match.
 *
 * @schema HttpProxySpecRoutesConditionsHeader
 */
export interface HttpProxySpecRoutesConditionsHeader {
  /**
   * Contains specifies a substring that must be present in the header value.
   *
   * @schema HttpProxySpecRoutesConditionsHeader#contains
   */
  readonly contains?: string;

  /**
   * Exact specifies a string that the header value must be equal to.
   *
   * @schema HttpProxySpecRoutesConditionsHeader#exact
   */
  readonly exact?: string;

  /**
   * Name is the name of the header to match against. Name is required. Header names are case insensitive.
   *
   * @schema HttpProxySpecRoutesConditionsHeader#name
   */
  readonly name: string;

  /**
   * NotContains specifies a substring that must not be present in the header value.
   *
   * @schema HttpProxySpecRoutesConditionsHeader#notcontains
   */
  readonly notcontains?: string;

  /**
   * NoExact specifies a string that the header value must not be equal to. The condition is true if the header has any other value.
   *
   * @schema HttpProxySpecRoutesConditionsHeader#notexact
   */
  readonly notexact?: string;

  /**
   * NotPresent specifies that condition is true when the named header is not present. Note that setting NotPresent to false does not make the condition true if the named header is present.
   *
   * @schema HttpProxySpecRoutesConditionsHeader#notpresent
   */
  readonly notpresent?: boolean;

  /**
   * Present specifies that condition is true when the named header is present, regardless of its value. Note that setting Present to false does not make the condition true if the named header is absent.
   *
   * @schema HttpProxySpecRoutesConditionsHeader#present
   */
  readonly present?: boolean;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesConditionsHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesConditionsHeader(obj: HttpProxySpecRoutesConditionsHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contains': obj.contains,
    'exact': obj.exact,
    'name': obj.name,
    'notcontains': obj.notcontains,
    'notexact': obj.notexact,
    'notpresent': obj.notpresent,
    'present': obj.present,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DomainRewrite enables rewriting the Set-Cookie Domain element. If not set, Domain will not be rewritten.
 *
 * @schema HttpProxySpecRoutesCookieRewritePoliciesDomainRewrite
 */
export interface HttpProxySpecRoutesCookieRewritePoliciesDomainRewrite {
  /**
   * Value is the value to rewrite the Domain attribute to. For now this is required.
   *
   * @schema HttpProxySpecRoutesCookieRewritePoliciesDomainRewrite#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesCookieRewritePoliciesDomainRewrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesCookieRewritePoliciesDomainRewrite(obj: HttpProxySpecRoutesCookieRewritePoliciesDomainRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PathRewrite enables rewriting the Set-Cookie Path element. If not set, Path will not be rewritten.
 *
 * @schema HttpProxySpecRoutesCookieRewritePoliciesPathRewrite
 */
export interface HttpProxySpecRoutesCookieRewritePoliciesPathRewrite {
  /**
   * Value is the value to rewrite the Path attribute to. For now this is required.
   *
   * @schema HttpProxySpecRoutesCookieRewritePoliciesPathRewrite#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesCookieRewritePoliciesPathRewrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesCookieRewritePoliciesPathRewrite(obj: HttpProxySpecRoutesCookieRewritePoliciesPathRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SameSite enables rewriting the Set-Cookie SameSite element. If not set, SameSite attribute will not be rewritten.
 *
 * @schema HttpProxySpecRoutesCookieRewritePoliciesSameSite
 */
export enum HttpProxySpecRoutesCookieRewritePoliciesSameSite {
  /** Strict */
  STRICT = 'Strict',
  /** Lax */
  LAX = 'Lax',
  /** None */
  NONE = 'None',
}

/**
 * RequestHashPolicy contains configuration for an individual hash policy on a request attribute.
 *
 * @schema HttpProxySpecRoutesLoadBalancerPolicyRequestHashPolicies
 */
export interface HttpProxySpecRoutesLoadBalancerPolicyRequestHashPolicies {
  /**
   * HashSourceIP should be set to true when request source IP hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.
   *
   * @schema HttpProxySpecRoutesLoadBalancerPolicyRequestHashPolicies#hashSourceIP
   */
  readonly hashSourceIp?: boolean;

  /**
   * HeaderHashOptions should be set when request header hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.
   *
   * @schema HttpProxySpecRoutesLoadBalancerPolicyRequestHashPolicies#headerHashOptions
   */
  readonly headerHashOptions?: HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions;

  /**
   * QueryParameterHashOptions should be set when request query parameter hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.
   *
   * @schema HttpProxySpecRoutesLoadBalancerPolicyRequestHashPolicies#queryParameterHashOptions
   */
  readonly queryParameterHashOptions?: HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions;

  /**
   * Terminal is a flag that allows for short-circuiting computing of a hash for a given request. If set to true, and the request attribute specified in the attribute hash options is present, no further hash policies will be used to calculate a hash for the request.
   *
   * @schema HttpProxySpecRoutesLoadBalancerPolicyRequestHashPolicies#terminal
   */
  readonly terminal?: boolean;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesLoadBalancerPolicyRequestHashPolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesLoadBalancerPolicyRequestHashPolicies(obj: HttpProxySpecRoutesLoadBalancerPolicyRequestHashPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hashSourceIP': obj.hashSourceIp,
    'headerHashOptions': toJson_HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions(obj.headerHashOptions),
    'queryParameterHashOptions': toJson_HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions(obj.queryParameterHashOptions),
    'terminal': obj.terminal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ReplacePrefix describes a path prefix replacement.
 *
 * @schema HttpProxySpecRoutesPathRewritePolicyReplacePrefix
 */
export interface HttpProxySpecRoutesPathRewritePolicyReplacePrefix {
  /**
   * Prefix specifies the URL path prefix to be replaced.
   * If Prefix is specified, it must exactly match the MatchCondition prefix that is rendered by the chain of including HTTPProxies and only that path prefix will be replaced by Replacement. This allows HTTPProxies that are included through multiple roots to only replace specific path prefixes, leaving others unmodified.
   * If Prefix is not specified, all routing prefixes rendered by the include chain will be replaced.
   *
   * @schema HttpProxySpecRoutesPathRewritePolicyReplacePrefix#prefix
   */
  readonly prefix?: string;

  /**
   * Replacement is the string that the routing path prefix will be replaced with. This must not be empty.
   *
   * @schema HttpProxySpecRoutesPathRewritePolicyReplacePrefix#replacement
   */
  readonly replacement: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesPathRewritePolicyReplacePrefix' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesPathRewritePolicyReplacePrefix(obj: HttpProxySpecRoutesPathRewritePolicyReplacePrefix | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prefix': obj.prefix,
    'replacement': obj.replacement,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Global defines global rate limiting parameters, i.e. parameters defining descriptors that are sent to an external rate limit service (RLS) for a rate limit decision on each request.
 *
 * @schema HttpProxySpecRoutesRateLimitPolicyGlobal
 */
export interface HttpProxySpecRoutesRateLimitPolicyGlobal {
  /**
   * Descriptors defines the list of descriptors that will be generated and sent to the rate limit service. Each descriptor contains 1+ key-value pair entries.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobal#descriptors
   */
  readonly descriptors?: HttpProxySpecRoutesRateLimitPolicyGlobalDescriptors[];

}

/**
 * Converts an object of type 'HttpProxySpecRoutesRateLimitPolicyGlobal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesRateLimitPolicyGlobal(obj: HttpProxySpecRoutesRateLimitPolicyGlobal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'descriptors': obj.descriptors?.map(y => toJson_HttpProxySpecRoutesRateLimitPolicyGlobalDescriptors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Local defines local rate limiting parameters, i.e. parameters for rate limiting that occurs within each Envoy pod as requests are handled.
 *
 * @schema HttpProxySpecRoutesRateLimitPolicyLocal
 */
export interface HttpProxySpecRoutesRateLimitPolicyLocal {
  /**
   * Burst defines the number of requests above the requests per unit that should be allowed within a short period of time.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyLocal#burst
   */
  readonly burst?: number;

  /**
   * Requests defines how many requests per unit of time should be allowed before rate limiting occurs.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyLocal#requests
   */
  readonly requests: number;

  /**
   * ResponseHeadersToAdd is an optional list of response headers to set when a request is rate-limited.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyLocal#responseHeadersToAdd
   */
  readonly responseHeadersToAdd?: HttpProxySpecRoutesRateLimitPolicyLocalResponseHeadersToAdd[];

  /**
   * ResponseStatusCode is the HTTP status code to use for responses to rate-limited requests. Codes must be in the 400-599 range (inclusive). If not specified, the Envoy default of 429 (Too Many Requests) is used.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyLocal#responseStatusCode
   */
  readonly responseStatusCode?: number;

  /**
   * Unit defines the period of time within which requests over the limit will be rate limited. Valid values are "second", "minute" and "hour".
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyLocal#unit
   */
  readonly unit: HttpProxySpecRoutesRateLimitPolicyLocalUnit;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesRateLimitPolicyLocal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesRateLimitPolicyLocal(obj: HttpProxySpecRoutesRateLimitPolicyLocal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'burst': obj.burst,
    'requests': obj.requests,
    'responseHeadersToAdd': obj.responseHeadersToAdd?.map(y => toJson_HttpProxySpecRoutesRateLimitPolicyLocalResponseHeadersToAdd(y)),
    'responseStatusCode': obj.responseStatusCode,
    'unit': obj.unit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HeaderValue represents a header name/value pair
 *
 * @schema HttpProxySpecRoutesRequestHeadersPolicySet
 */
export interface HttpProxySpecRoutesRequestHeadersPolicySet {
  /**
   * Name represents a key of a header
   *
   * @schema HttpProxySpecRoutesRequestHeadersPolicySet#name
   */
  readonly name: string;

  /**
   * Value represents the value of a header specified by a key
   *
   * @schema HttpProxySpecRoutesRequestHeadersPolicySet#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesRequestHeadersPolicySet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesRequestHeadersPolicySet(obj: HttpProxySpecRoutesRequestHeadersPolicySet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Scheme is the scheme to be used in the value of the `Location` header in the response. When empty, the scheme of the request is used.
 *
 * @schema HttpProxySpecRoutesRequestRedirectPolicyScheme
 */
export enum HttpProxySpecRoutesRequestRedirectPolicyScheme {
  /** http */
  HTTP = 'http',
  /** https */
  HTTPS = 'https',
}

/**
 * HeaderValue represents a header name/value pair
 *
 * @schema HttpProxySpecRoutesResponseHeadersPolicySet
 */
export interface HttpProxySpecRoutesResponseHeadersPolicySet {
  /**
   * Name represents a key of a header
   *
   * @schema HttpProxySpecRoutesResponseHeadersPolicySet#name
   */
  readonly name: string;

  /**
   * Value represents the value of a header specified by a key
   *
   * @schema HttpProxySpecRoutesResponseHeadersPolicySet#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesResponseHeadersPolicySet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesResponseHeadersPolicySet(obj: HttpProxySpecRoutesResponseHeadersPolicySet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RetryOn is a string type alias with validation to ensure that the value is valid.
 *
 * @schema HttpProxySpecRoutesRetryPolicyRetryOn
 */
export enum HttpProxySpecRoutesRetryPolicyRetryOn {
  /** 5xx */
  VALUE_5XX = '5xx',
  /** gateway-error */
  GATEWAY_ERROR = 'gateway-error',
  /** reset */
  RESET = 'reset',
  /** connect-failure */
  CONNECT_FAILURE = 'connect-failure',
  /** retriable-4xx */
  RETRIABLE_4XX = 'retriable-4xx',
  /** refused-stream */
  REFUSED_STREAM = 'refused-stream',
  /** retriable-status-codes */
  RETRIABLE_STATUS_CODES = 'retriable-status-codes',
  /** retriable-headers */
  RETRIABLE_HEADERS = 'retriable-headers',
  /** cancelled */
  CANCELLED = 'cancelled',
  /** deadline-exceeded */
  DEADLINE_EXCEEDED = 'deadline-exceeded',
  /** internal */
  INTERNAL = 'internal',
  /** resource-exhausted */
  RESOURCE_EXHAUSTED = 'resource-exhausted',
  /** unavailable */
  UNAVAILABLE = 'unavailable',
}

/**
 * @schema HttpProxySpecRoutesServicesCookieRewritePolicies
 */
export interface HttpProxySpecRoutesServicesCookieRewritePolicies {
  /**
   * DomainRewrite enables rewriting the Set-Cookie Domain element. If not set, Domain will not be rewritten.
   *
   * @schema HttpProxySpecRoutesServicesCookieRewritePolicies#domainRewrite
   */
  readonly domainRewrite?: HttpProxySpecRoutesServicesCookieRewritePoliciesDomainRewrite;

  /**
   * Name is the name of the cookie for which attributes will be rewritten.
   *
   * @schema HttpProxySpecRoutesServicesCookieRewritePolicies#name
   */
  readonly name: string;

  /**
   * PathRewrite enables rewriting the Set-Cookie Path element. If not set, Path will not be rewritten.
   *
   * @schema HttpProxySpecRoutesServicesCookieRewritePolicies#pathRewrite
   */
  readonly pathRewrite?: HttpProxySpecRoutesServicesCookieRewritePoliciesPathRewrite;

  /**
   * SameSite enables rewriting the Set-Cookie SameSite element. If not set, SameSite attribute will not be rewritten.
   *
   * @schema HttpProxySpecRoutesServicesCookieRewritePolicies#sameSite
   */
  readonly sameSite?: HttpProxySpecRoutesServicesCookieRewritePoliciesSameSite;

  /**
   * Secure enables rewriting the Set-Cookie Secure element. If not set, Secure attribute will not be rewritten.
   *
   * @schema HttpProxySpecRoutesServicesCookieRewritePolicies#secure
   */
  readonly secure?: boolean;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesServicesCookieRewritePolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesServicesCookieRewritePolicies(obj: HttpProxySpecRoutesServicesCookieRewritePolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domainRewrite': toJson_HttpProxySpecRoutesServicesCookieRewritePoliciesDomainRewrite(obj.domainRewrite),
    'name': obj.name,
    'pathRewrite': toJson_HttpProxySpecRoutesServicesCookieRewritePoliciesPathRewrite(obj.pathRewrite),
    'sameSite': obj.sameSite,
    'secure': obj.secure,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Protocol may be used to specify (or override) the protocol used to reach this Service. Values may be tls, h2, h2c. If omitted, protocol-selection falls back on Service annotations.
 *
 * @schema HttpProxySpecRoutesServicesProtocol
 */
export enum HttpProxySpecRoutesServicesProtocol {
  /** h2 */
  H2 = 'h2',
  /** h2c */
  H2C = 'h2c',
  /** tls */
  TLS = 'tls',
}

/**
 * The policy for managing request headers during proxying. Rewriting the 'Host' header is not supported.
 *
 * @schema HttpProxySpecRoutesServicesRequestHeadersPolicy
 */
export interface HttpProxySpecRoutesServicesRequestHeadersPolicy {
  /**
   * Remove specifies a list of HTTP header names to remove.
   *
   * @schema HttpProxySpecRoutesServicesRequestHeadersPolicy#remove
   */
  readonly remove?: string[];

  /**
   * Set specifies a list of HTTP header values that will be set in the HTTP header. If the header does not exist it will be added, otherwise it will be overwritten with the new value.
   *
   * @schema HttpProxySpecRoutesServicesRequestHeadersPolicy#set
   */
  readonly set?: HttpProxySpecRoutesServicesRequestHeadersPolicySet[];

}

/**
 * Converts an object of type 'HttpProxySpecRoutesServicesRequestHeadersPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesServicesRequestHeadersPolicy(obj: HttpProxySpecRoutesServicesRequestHeadersPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'remove': obj.remove?.map(y => y),
    'set': obj.set?.map(y => toJson_HttpProxySpecRoutesServicesRequestHeadersPolicySet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The policy for managing response headers during proxying. Rewriting the 'Host' header is not supported.
 *
 * @schema HttpProxySpecRoutesServicesResponseHeadersPolicy
 */
export interface HttpProxySpecRoutesServicesResponseHeadersPolicy {
  /**
   * Remove specifies a list of HTTP header names to remove.
   *
   * @schema HttpProxySpecRoutesServicesResponseHeadersPolicy#remove
   */
  readonly remove?: string[];

  /**
   * Set specifies a list of HTTP header values that will be set in the HTTP header. If the header does not exist it will be added, otherwise it will be overwritten with the new value.
   *
   * @schema HttpProxySpecRoutesServicesResponseHeadersPolicy#set
   */
  readonly set?: HttpProxySpecRoutesServicesResponseHeadersPolicySet[];

}

/**
 * Converts an object of type 'HttpProxySpecRoutesServicesResponseHeadersPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesServicesResponseHeadersPolicy(obj: HttpProxySpecRoutesServicesResponseHeadersPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'remove': obj.remove?.map(y => y),
    'set': obj.set?.map(y => toJson_HttpProxySpecRoutesServicesResponseHeadersPolicySet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UpstreamValidation defines how to verify the backend service's certificate
 *
 * @schema HttpProxySpecRoutesServicesValidation
 */
export interface HttpProxySpecRoutesServicesValidation {
  /**
   * Name or namespaced name of the Kubernetes secret used to validate the certificate presented by the backend. The secret must contain key named ca.crt.
   *
   * @schema HttpProxySpecRoutesServicesValidation#caSecret
   */
  readonly caSecret: string;

  /**
   * Key which is expected to be present in the 'subjectAltName' of the presented certificate.
   *
   * @schema HttpProxySpecRoutesServicesValidation#subjectName
   */
  readonly subjectName: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesServicesValidation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesServicesValidation(obj: HttpProxySpecRoutesServicesValidation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caSecret': obj.caSecret,
    'subjectName': obj.subjectName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RequestHashPolicy contains configuration for an individual hash policy on a request attribute.
 *
 * @schema HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPolicies
 */
export interface HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPolicies {
  /**
   * HashSourceIP should be set to true when request source IP hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.
   *
   * @schema HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPolicies#hashSourceIP
   */
  readonly hashSourceIp?: boolean;

  /**
   * HeaderHashOptions should be set when request header hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.
   *
   * @schema HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPolicies#headerHashOptions
   */
  readonly headerHashOptions?: HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions;

  /**
   * QueryParameterHashOptions should be set when request query parameter hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.
   *
   * @schema HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPolicies#queryParameterHashOptions
   */
  readonly queryParameterHashOptions?: HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions;

  /**
   * Terminal is a flag that allows for short-circuiting computing of a hash for a given request. If set to true, and the request attribute specified in the attribute hash options is present, no further hash policies will be used to calculate a hash for the request.
   *
   * @schema HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPolicies#terminal
   */
  readonly terminal?: boolean;

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPolicies(obj: HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hashSourceIP': obj.hashSourceIp,
    'headerHashOptions': toJson_HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions(obj.headerHashOptions),
    'queryParameterHashOptions': toJson_HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions(obj.queryParameterHashOptions),
    'terminal': obj.terminal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema HttpProxySpecTcpproxyServicesCookieRewritePolicies
 */
export interface HttpProxySpecTcpproxyServicesCookieRewritePolicies {
  /**
   * DomainRewrite enables rewriting the Set-Cookie Domain element. If not set, Domain will not be rewritten.
   *
   * @schema HttpProxySpecTcpproxyServicesCookieRewritePolicies#domainRewrite
   */
  readonly domainRewrite?: HttpProxySpecTcpproxyServicesCookieRewritePoliciesDomainRewrite;

  /**
   * Name is the name of the cookie for which attributes will be rewritten.
   *
   * @schema HttpProxySpecTcpproxyServicesCookieRewritePolicies#name
   */
  readonly name: string;

  /**
   * PathRewrite enables rewriting the Set-Cookie Path element. If not set, Path will not be rewritten.
   *
   * @schema HttpProxySpecTcpproxyServicesCookieRewritePolicies#pathRewrite
   */
  readonly pathRewrite?: HttpProxySpecTcpproxyServicesCookieRewritePoliciesPathRewrite;

  /**
   * SameSite enables rewriting the Set-Cookie SameSite element. If not set, SameSite attribute will not be rewritten.
   *
   * @schema HttpProxySpecTcpproxyServicesCookieRewritePolicies#sameSite
   */
  readonly sameSite?: HttpProxySpecTcpproxyServicesCookieRewritePoliciesSameSite;

  /**
   * Secure enables rewriting the Set-Cookie Secure element. If not set, Secure attribute will not be rewritten.
   *
   * @schema HttpProxySpecTcpproxyServicesCookieRewritePolicies#secure
   */
  readonly secure?: boolean;

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyServicesCookieRewritePolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyServicesCookieRewritePolicies(obj: HttpProxySpecTcpproxyServicesCookieRewritePolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domainRewrite': toJson_HttpProxySpecTcpproxyServicesCookieRewritePoliciesDomainRewrite(obj.domainRewrite),
    'name': obj.name,
    'pathRewrite': toJson_HttpProxySpecTcpproxyServicesCookieRewritePoliciesPathRewrite(obj.pathRewrite),
    'sameSite': obj.sameSite,
    'secure': obj.secure,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Protocol may be used to specify (or override) the protocol used to reach this Service. Values may be tls, h2, h2c. If omitted, protocol-selection falls back on Service annotations.
 *
 * @schema HttpProxySpecTcpproxyServicesProtocol
 */
export enum HttpProxySpecTcpproxyServicesProtocol {
  /** h2 */
  H2 = 'h2',
  /** h2c */
  H2C = 'h2c',
  /** tls */
  TLS = 'tls',
}

/**
 * The policy for managing request headers during proxying. Rewriting the 'Host' header is not supported.
 *
 * @schema HttpProxySpecTcpproxyServicesRequestHeadersPolicy
 */
export interface HttpProxySpecTcpproxyServicesRequestHeadersPolicy {
  /**
   * Remove specifies a list of HTTP header names to remove.
   *
   * @schema HttpProxySpecTcpproxyServicesRequestHeadersPolicy#remove
   */
  readonly remove?: string[];

  /**
   * Set specifies a list of HTTP header values that will be set in the HTTP header. If the header does not exist it will be added, otherwise it will be overwritten with the new value.
   *
   * @schema HttpProxySpecTcpproxyServicesRequestHeadersPolicy#set
   */
  readonly set?: HttpProxySpecTcpproxyServicesRequestHeadersPolicySet[];

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyServicesRequestHeadersPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyServicesRequestHeadersPolicy(obj: HttpProxySpecTcpproxyServicesRequestHeadersPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'remove': obj.remove?.map(y => y),
    'set': obj.set?.map(y => toJson_HttpProxySpecTcpproxyServicesRequestHeadersPolicySet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The policy for managing response headers during proxying. Rewriting the 'Host' header is not supported.
 *
 * @schema HttpProxySpecTcpproxyServicesResponseHeadersPolicy
 */
export interface HttpProxySpecTcpproxyServicesResponseHeadersPolicy {
  /**
   * Remove specifies a list of HTTP header names to remove.
   *
   * @schema HttpProxySpecTcpproxyServicesResponseHeadersPolicy#remove
   */
  readonly remove?: string[];

  /**
   * Set specifies a list of HTTP header values that will be set in the HTTP header. If the header does not exist it will be added, otherwise it will be overwritten with the new value.
   *
   * @schema HttpProxySpecTcpproxyServicesResponseHeadersPolicy#set
   */
  readonly set?: HttpProxySpecTcpproxyServicesResponseHeadersPolicySet[];

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyServicesResponseHeadersPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyServicesResponseHeadersPolicy(obj: HttpProxySpecTcpproxyServicesResponseHeadersPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'remove': obj.remove?.map(y => y),
    'set': obj.set?.map(y => toJson_HttpProxySpecTcpproxyServicesResponseHeadersPolicySet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UpstreamValidation defines how to verify the backend service's certificate
 *
 * @schema HttpProxySpecTcpproxyServicesValidation
 */
export interface HttpProxySpecTcpproxyServicesValidation {
  /**
   * Name or namespaced name of the Kubernetes secret used to validate the certificate presented by the backend. The secret must contain key named ca.crt.
   *
   * @schema HttpProxySpecTcpproxyServicesValidation#caSecret
   */
  readonly caSecret: string;

  /**
   * Key which is expected to be present in the 'subjectAltName' of the presented certificate.
   *
   * @schema HttpProxySpecTcpproxyServicesValidation#subjectName
   */
  readonly subjectName: string;

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyServicesValidation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyServicesValidation(obj: HttpProxySpecTcpproxyServicesValidation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caSecret': obj.caSecret,
    'subjectName': obj.subjectName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AuthPolicy sets a default authorization policy for client requests. This policy will be used unless overridden by individual routes.
 *
 * @schema HttpProxySpecVirtualhostAuthorizationAuthPolicy
 */
export interface HttpProxySpecVirtualhostAuthorizationAuthPolicy {
  /**
   * Context is a set of key/value pairs that are sent to the authentication server in the check request. If a context is provided at an enclosing scope, the entries are merged such that the inner scope overrides matching keys from the outer scope.
   *
   * @schema HttpProxySpecVirtualhostAuthorizationAuthPolicy#context
   */
  readonly context?: { [key: string]: string };

  /**
   * When true, this field disables client request authentication for the scope of the policy.
   *
   * @schema HttpProxySpecVirtualhostAuthorizationAuthPolicy#disabled
   */
  readonly disabled?: boolean;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostAuthorizationAuthPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostAuthorizationAuthPolicy(obj: HttpProxySpecVirtualhostAuthorizationAuthPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': ((obj.context) === undefined) ? undefined : (Object.entries(obj.context).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'disabled': obj.disabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExtensionServiceRef specifies the extension resource that will authorize client requests.
 *
 * @schema HttpProxySpecVirtualhostAuthorizationExtensionRef
 */
export interface HttpProxySpecVirtualhostAuthorizationExtensionRef {
  /**
   * API version of the referent. If this field is not specified, the default "projectcontour.io/v1alpha1" will be used
   *
   * @schema HttpProxySpecVirtualhostAuthorizationExtensionRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema HttpProxySpecVirtualhostAuthorizationExtensionRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. If this field is not specifies, the namespace of the resource that targets the referent will be used.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema HttpProxySpecVirtualhostAuthorizationExtensionRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostAuthorizationExtensionRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostAuthorizationExtensionRef(obj: HttpProxySpecVirtualhostAuthorizationExtensionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WithRequestBody specifies configuration for sending the client request's body to authorization server.
 *
 * @schema HttpProxySpecVirtualhostAuthorizationWithRequestBody
 */
export interface HttpProxySpecVirtualhostAuthorizationWithRequestBody {
  /**
   * If AllowPartialMessage is true, then Envoy will buffer the body until MaxRequestBytes are reached.
   *
   * @schema HttpProxySpecVirtualhostAuthorizationWithRequestBody#allowPartialMessage
   */
  readonly allowPartialMessage?: boolean;

  /**
   * MaxRequestBytes sets the maximum size of message body ExtAuthz filter will hold in-memory.
   *
   * @schema HttpProxySpecVirtualhostAuthorizationWithRequestBody#maxRequestBytes
   */
  readonly maxRequestBytes?: number;

  /**
   * If PackAsBytes is true, the body sent to Authorization Server is in raw bytes.
   *
   * @schema HttpProxySpecVirtualhostAuthorizationWithRequestBody#packAsBytes
   */
  readonly packAsBytes?: boolean;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostAuthorizationWithRequestBody' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostAuthorizationWithRequestBody(obj: HttpProxySpecVirtualhostAuthorizationWithRequestBody | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPartialMessage': obj.allowPartialMessage,
    'maxRequestBytes': obj.maxRequestBytes,
    'packAsBytes': obj.packAsBytes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Global defines global rate limiting parameters, i.e. parameters defining descriptors that are sent to an external rate limit service (RLS) for a rate limit decision on each request.
 *
 * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobal
 */
export interface HttpProxySpecVirtualhostRateLimitPolicyGlobal {
  /**
   * Descriptors defines the list of descriptors that will be generated and sent to the rate limit service. Each descriptor contains 1+ key-value pair entries.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobal#descriptors
   */
  readonly descriptors?: HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptors[];

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostRateLimitPolicyGlobal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostRateLimitPolicyGlobal(obj: HttpProxySpecVirtualhostRateLimitPolicyGlobal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'descriptors': obj.descriptors?.map(y => toJson_HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Local defines local rate limiting parameters, i.e. parameters for rate limiting that occurs within each Envoy pod as requests are handled.
 *
 * @schema HttpProxySpecVirtualhostRateLimitPolicyLocal
 */
export interface HttpProxySpecVirtualhostRateLimitPolicyLocal {
  /**
   * Burst defines the number of requests above the requests per unit that should be allowed within a short period of time.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyLocal#burst
   */
  readonly burst?: number;

  /**
   * Requests defines how many requests per unit of time should be allowed before rate limiting occurs.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyLocal#requests
   */
  readonly requests: number;

  /**
   * ResponseHeadersToAdd is an optional list of response headers to set when a request is rate-limited.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyLocal#responseHeadersToAdd
   */
  readonly responseHeadersToAdd?: HttpProxySpecVirtualhostRateLimitPolicyLocalResponseHeadersToAdd[];

  /**
   * ResponseStatusCode is the HTTP status code to use for responses to rate-limited requests. Codes must be in the 400-599 range (inclusive). If not specified, the Envoy default of 429 (Too Many Requests) is used.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyLocal#responseStatusCode
   */
  readonly responseStatusCode?: number;

  /**
   * Unit defines the period of time within which requests over the limit will be rate limited. Valid values are "second", "minute" and "hour".
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyLocal#unit
   */
  readonly unit: HttpProxySpecVirtualhostRateLimitPolicyLocalUnit;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostRateLimitPolicyLocal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostRateLimitPolicyLocal(obj: HttpProxySpecVirtualhostRateLimitPolicyLocal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'burst': obj.burst,
    'requests': obj.requests,
    'responseHeadersToAdd': obj.responseHeadersToAdd?.map(y => toJson_HttpProxySpecVirtualhostRateLimitPolicyLocalResponseHeadersToAdd(y)),
    'responseStatusCode': obj.responseStatusCode,
    'unit': obj.unit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClientValidation defines how to verify the client certificate when an external client establishes a TLS connection to Envoy.
 * This setting:
 * 1. Enables TLS client certificate validation. 2. Specifies how the client certificate will be validated (i.e.    validation required or skipped).
 * Note: Setting client certificate validation to be skipped should be only used in conjunction with an external authorization server that performs client validation as Contour will ensure client certificates are passed along.
 *
 * @schema HttpProxySpecVirtualhostTlsClientValidation
 */
export interface HttpProxySpecVirtualhostTlsClientValidation {
  /**
   * Name of a Kubernetes secret that contains a CA certificate bundle. The secret must contain key named ca.crt. The client certificate must validate against the certificates in the bundle. If specified and SkipClientCertValidation is true, client certificates will be required on requests.
   *
   * @schema HttpProxySpecVirtualhostTlsClientValidation#caSecret
   */
  readonly caSecret?: string;

  /**
   * If this option is set to true, only the certificate at the end of the certificate chain will be subject to validation by CRL.
   *
   * @schema HttpProxySpecVirtualhostTlsClientValidation#crlOnlyVerifyLeafCert
   */
  readonly crlOnlyVerifyLeafCert?: boolean;

  /**
   * Name of a Kubernetes opaque secret that contains a concatenated list of PEM encoded CRLs. The secret must contain key named crl.pem. This field will be used to verify that a client certificate has not been revoked. CRLs must be available from all CAs, unless crlOnlyVerifyLeafCert is true. Large CRL lists are not supported since individual secrets are limited to 1MiB in size.
   *
   * @schema HttpProxySpecVirtualhostTlsClientValidation#crlSecret
   */
  readonly crlSecret?: string;

  /**
   * SkipClientCertValidation disables downstream client certificate validation. Defaults to false. This field is intended to be used in conjunction with external authorization in order to enable the external authorization server to validate client certificates. When this field is set to true, client certificates are requested but not verified by Envoy. If CACertificate is specified, client certificates are required on requests, but not verified. If external authorization is in use, they are presented to the external authorization server.
   *
   * @default false. This field is intended to be used in conjunction with external authorization in order to enable the external authorization server to validate client certificates. When this field is set to true, client certificates are requested but not verified by Envoy. If CACertificate is specified, client certificates are required on requests, but not verified. If external authorization is in use, they are presented to the external authorization server.
   * @schema HttpProxySpecVirtualhostTlsClientValidation#skipClientCertValidation
   */
  readonly skipClientCertValidation?: boolean;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostTlsClientValidation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostTlsClientValidation(obj: HttpProxySpecVirtualhostTlsClientValidation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caSecret': obj.caSecret,
    'crlOnlyVerifyLeafCert': obj.crlOnlyVerifyLeafCert,
    'crlSecret': obj.crlSecret,
    'skipClientCertValidation': obj.skipClientCertValidation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HeaderHashOptions should be set when request header hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.
 *
 * @schema HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions
 */
export interface HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions {
  /**
   * HeaderName is the name of the HTTP request header that will be used to calculate the hash key. If the header specified is not present on a request, no hash will be produced.
   *
   * @schema HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions#headerName
   */
  readonly headerName?: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions(obj: HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerName': obj.headerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * QueryParameterHashOptions should be set when request query parameter hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.
 *
 * @schema HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions
 */
export interface HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions {
  /**
   * ParameterName is the name of the HTTP request query parameter that will be used to calculate the hash key. If the query parameter specified is not present on a request, no hash will be produced.
   *
   * @schema HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions#parameterName
   */
  readonly parameterName?: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions(obj: HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameterName': obj.parameterName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RateLimitDescriptor defines a list of key-value pair generators.
 *
 * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptors
 */
export interface HttpProxySpecRoutesRateLimitPolicyGlobalDescriptors {
  /**
   * Entries is the list of key-value pair generators.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptors#entries
   */
  readonly entries?: HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntries[];

}

/**
 * Converts an object of type 'HttpProxySpecRoutesRateLimitPolicyGlobalDescriptors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesRateLimitPolicyGlobalDescriptors(obj: HttpProxySpecRoutesRateLimitPolicyGlobalDescriptors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'entries': obj.entries?.map(y => toJson_HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntries(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HeaderValue represents a header name/value pair
 *
 * @schema HttpProxySpecRoutesRateLimitPolicyLocalResponseHeadersToAdd
 */
export interface HttpProxySpecRoutesRateLimitPolicyLocalResponseHeadersToAdd {
  /**
   * Name represents a key of a header
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyLocalResponseHeadersToAdd#name
   */
  readonly name: string;

  /**
   * Value represents the value of a header specified by a key
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyLocalResponseHeadersToAdd#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesRateLimitPolicyLocalResponseHeadersToAdd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesRateLimitPolicyLocalResponseHeadersToAdd(obj: HttpProxySpecRoutesRateLimitPolicyLocalResponseHeadersToAdd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Unit defines the period of time within which requests over the limit will be rate limited. Valid values are "second", "minute" and "hour".
 *
 * @schema HttpProxySpecRoutesRateLimitPolicyLocalUnit
 */
export enum HttpProxySpecRoutesRateLimitPolicyLocalUnit {
  /** second */
  SECOND = 'second',
  /** minute */
  MINUTE = 'minute',
  /** hour */
  HOUR = 'hour',
}

/**
 * DomainRewrite enables rewriting the Set-Cookie Domain element. If not set, Domain will not be rewritten.
 *
 * @schema HttpProxySpecRoutesServicesCookieRewritePoliciesDomainRewrite
 */
export interface HttpProxySpecRoutesServicesCookieRewritePoliciesDomainRewrite {
  /**
   * Value is the value to rewrite the Domain attribute to. For now this is required.
   *
   * @schema HttpProxySpecRoutesServicesCookieRewritePoliciesDomainRewrite#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesServicesCookieRewritePoliciesDomainRewrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesServicesCookieRewritePoliciesDomainRewrite(obj: HttpProxySpecRoutesServicesCookieRewritePoliciesDomainRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PathRewrite enables rewriting the Set-Cookie Path element. If not set, Path will not be rewritten.
 *
 * @schema HttpProxySpecRoutesServicesCookieRewritePoliciesPathRewrite
 */
export interface HttpProxySpecRoutesServicesCookieRewritePoliciesPathRewrite {
  /**
   * Value is the value to rewrite the Path attribute to. For now this is required.
   *
   * @schema HttpProxySpecRoutesServicesCookieRewritePoliciesPathRewrite#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesServicesCookieRewritePoliciesPathRewrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesServicesCookieRewritePoliciesPathRewrite(obj: HttpProxySpecRoutesServicesCookieRewritePoliciesPathRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SameSite enables rewriting the Set-Cookie SameSite element. If not set, SameSite attribute will not be rewritten.
 *
 * @schema HttpProxySpecRoutesServicesCookieRewritePoliciesSameSite
 */
export enum HttpProxySpecRoutesServicesCookieRewritePoliciesSameSite {
  /** Strict */
  STRICT = 'Strict',
  /** Lax */
  LAX = 'Lax',
  /** None */
  NONE = 'None',
}

/**
 * HeaderValue represents a header name/value pair
 *
 * @schema HttpProxySpecRoutesServicesRequestHeadersPolicySet
 */
export interface HttpProxySpecRoutesServicesRequestHeadersPolicySet {
  /**
   * Name represents a key of a header
   *
   * @schema HttpProxySpecRoutesServicesRequestHeadersPolicySet#name
   */
  readonly name: string;

  /**
   * Value represents the value of a header specified by a key
   *
   * @schema HttpProxySpecRoutesServicesRequestHeadersPolicySet#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesServicesRequestHeadersPolicySet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesServicesRequestHeadersPolicySet(obj: HttpProxySpecRoutesServicesRequestHeadersPolicySet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HeaderValue represents a header name/value pair
 *
 * @schema HttpProxySpecRoutesServicesResponseHeadersPolicySet
 */
export interface HttpProxySpecRoutesServicesResponseHeadersPolicySet {
  /**
   * Name represents a key of a header
   *
   * @schema HttpProxySpecRoutesServicesResponseHeadersPolicySet#name
   */
  readonly name: string;

  /**
   * Value represents the value of a header specified by a key
   *
   * @schema HttpProxySpecRoutesServicesResponseHeadersPolicySet#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesServicesResponseHeadersPolicySet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesServicesResponseHeadersPolicySet(obj: HttpProxySpecRoutesServicesResponseHeadersPolicySet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HeaderHashOptions should be set when request header hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.
 *
 * @schema HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions
 */
export interface HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions {
  /**
   * HeaderName is the name of the HTTP request header that will be used to calculate the hash key. If the header specified is not present on a request, no hash will be produced.
   *
   * @schema HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions#headerName
   */
  readonly headerName?: string;

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions(obj: HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerName': obj.headerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * QueryParameterHashOptions should be set when request query parameter hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.
 *
 * @schema HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions
 */
export interface HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions {
  /**
   * ParameterName is the name of the HTTP request query parameter that will be used to calculate the hash key. If the query parameter specified is not present on a request, no hash will be produced.
   *
   * @schema HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions#parameterName
   */
  readonly parameterName?: string;

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions(obj: HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameterName': obj.parameterName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DomainRewrite enables rewriting the Set-Cookie Domain element. If not set, Domain will not be rewritten.
 *
 * @schema HttpProxySpecTcpproxyServicesCookieRewritePoliciesDomainRewrite
 */
export interface HttpProxySpecTcpproxyServicesCookieRewritePoliciesDomainRewrite {
  /**
   * Value is the value to rewrite the Domain attribute to. For now this is required.
   *
   * @schema HttpProxySpecTcpproxyServicesCookieRewritePoliciesDomainRewrite#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyServicesCookieRewritePoliciesDomainRewrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyServicesCookieRewritePoliciesDomainRewrite(obj: HttpProxySpecTcpproxyServicesCookieRewritePoliciesDomainRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PathRewrite enables rewriting the Set-Cookie Path element. If not set, Path will not be rewritten.
 *
 * @schema HttpProxySpecTcpproxyServicesCookieRewritePoliciesPathRewrite
 */
export interface HttpProxySpecTcpproxyServicesCookieRewritePoliciesPathRewrite {
  /**
   * Value is the value to rewrite the Path attribute to. For now this is required.
   *
   * @schema HttpProxySpecTcpproxyServicesCookieRewritePoliciesPathRewrite#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyServicesCookieRewritePoliciesPathRewrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyServicesCookieRewritePoliciesPathRewrite(obj: HttpProxySpecTcpproxyServicesCookieRewritePoliciesPathRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SameSite enables rewriting the Set-Cookie SameSite element. If not set, SameSite attribute will not be rewritten.
 *
 * @schema HttpProxySpecTcpproxyServicesCookieRewritePoliciesSameSite
 */
export enum HttpProxySpecTcpproxyServicesCookieRewritePoliciesSameSite {
  /** Strict */
  STRICT = 'Strict',
  /** Lax */
  LAX = 'Lax',
  /** None */
  NONE = 'None',
}

/**
 * HeaderValue represents a header name/value pair
 *
 * @schema HttpProxySpecTcpproxyServicesRequestHeadersPolicySet
 */
export interface HttpProxySpecTcpproxyServicesRequestHeadersPolicySet {
  /**
   * Name represents a key of a header
   *
   * @schema HttpProxySpecTcpproxyServicesRequestHeadersPolicySet#name
   */
  readonly name: string;

  /**
   * Value represents the value of a header specified by a key
   *
   * @schema HttpProxySpecTcpproxyServicesRequestHeadersPolicySet#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyServicesRequestHeadersPolicySet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyServicesRequestHeadersPolicySet(obj: HttpProxySpecTcpproxyServicesRequestHeadersPolicySet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HeaderValue represents a header name/value pair
 *
 * @schema HttpProxySpecTcpproxyServicesResponseHeadersPolicySet
 */
export interface HttpProxySpecTcpproxyServicesResponseHeadersPolicySet {
  /**
   * Name represents a key of a header
   *
   * @schema HttpProxySpecTcpproxyServicesResponseHeadersPolicySet#name
   */
  readonly name: string;

  /**
   * Value represents the value of a header specified by a key
   *
   * @schema HttpProxySpecTcpproxyServicesResponseHeadersPolicySet#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyServicesResponseHeadersPolicySet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyServicesResponseHeadersPolicySet(obj: HttpProxySpecTcpproxyServicesResponseHeadersPolicySet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RateLimitDescriptor defines a list of key-value pair generators.
 *
 * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptors
 */
export interface HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptors {
  /**
   * Entries is the list of key-value pair generators.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptors#entries
   */
  readonly entries?: HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntries[];

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptors(obj: HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'entries': obj.entries?.map(y => toJson_HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntries(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HeaderValue represents a header name/value pair
 *
 * @schema HttpProxySpecVirtualhostRateLimitPolicyLocalResponseHeadersToAdd
 */
export interface HttpProxySpecVirtualhostRateLimitPolicyLocalResponseHeadersToAdd {
  /**
   * Name represents a key of a header
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyLocalResponseHeadersToAdd#name
   */
  readonly name: string;

  /**
   * Value represents the value of a header specified by a key
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyLocalResponseHeadersToAdd#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostRateLimitPolicyLocalResponseHeadersToAdd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostRateLimitPolicyLocalResponseHeadersToAdd(obj: HttpProxySpecVirtualhostRateLimitPolicyLocalResponseHeadersToAdd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Unit defines the period of time within which requests over the limit will be rate limited. Valid values are "second", "minute" and "hour".
 *
 * @schema HttpProxySpecVirtualhostRateLimitPolicyLocalUnit
 */
export enum HttpProxySpecVirtualhostRateLimitPolicyLocalUnit {
  /** second */
  SECOND = 'second',
  /** minute */
  MINUTE = 'minute',
  /** hour */
  HOUR = 'hour',
}

/**
 * RateLimitDescriptorEntry is a key-value pair generator. Exactly one field on this struct must be non-nil.
 *
 * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntries
 */
export interface HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntries {
  /**
   * GenericKey defines a descriptor entry with a static key and value.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntries#genericKey
   */
  readonly genericKey?: HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesGenericKey;

  /**
   * RemoteAddress defines a descriptor entry with a key of "remote_address" and a value equal to the client's IP address (from x-forwarded-for).
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntries#remoteAddress
   */
  readonly remoteAddress?: any;

  /**
   * RequestHeader defines a descriptor entry that's populated only if a given header is present on the request. The descriptor key is static, and the descriptor value is equal to the value of the header.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntries#requestHeader
   */
  readonly requestHeader?: HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeader;

  /**
   * RequestHeaderValueMatch defines a descriptor entry that's populated if the request's headers match a set of 1+ match criteria. The descriptor key is "header_match", and the descriptor value is static.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntries#requestHeaderValueMatch
   */
  readonly requestHeaderValueMatch?: HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntries' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntries(obj: HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntries | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'genericKey': toJson_HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesGenericKey(obj.genericKey),
    'remoteAddress': obj.remoteAddress,
    'requestHeader': toJson_HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeader(obj.requestHeader),
    'requestHeaderValueMatch': toJson_HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch(obj.requestHeaderValueMatch),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RateLimitDescriptorEntry is a key-value pair generator. Exactly one field on this struct must be non-nil.
 *
 * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntries
 */
export interface HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntries {
  /**
   * GenericKey defines a descriptor entry with a static key and value.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntries#genericKey
   */
  readonly genericKey?: HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesGenericKey;

  /**
   * RemoteAddress defines a descriptor entry with a key of "remote_address" and a value equal to the client's IP address (from x-forwarded-for).
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntries#remoteAddress
   */
  readonly remoteAddress?: any;

  /**
   * RequestHeader defines a descriptor entry that's populated only if a given header is present on the request. The descriptor key is static, and the descriptor value is equal to the value of the header.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntries#requestHeader
   */
  readonly requestHeader?: HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeader;

  /**
   * RequestHeaderValueMatch defines a descriptor entry that's populated if the request's headers match a set of 1+ match criteria. The descriptor key is "header_match", and the descriptor value is static.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntries#requestHeaderValueMatch
   */
  readonly requestHeaderValueMatch?: HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntries' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntries(obj: HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntries | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'genericKey': toJson_HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesGenericKey(obj.genericKey),
    'remoteAddress': obj.remoteAddress,
    'requestHeader': toJson_HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeader(obj.requestHeader),
    'requestHeaderValueMatch': toJson_HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch(obj.requestHeaderValueMatch),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GenericKey defines a descriptor entry with a static key and value.
 *
 * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesGenericKey
 */
export interface HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesGenericKey {
  /**
   * Key defines the key of the descriptor entry. If not set, the key is set to "generic_key".
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesGenericKey#key
   */
  readonly key?: string;

  /**
   * Value defines the value of the descriptor entry.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesGenericKey#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesGenericKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesGenericKey(obj: HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesGenericKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RequestHeader defines a descriptor entry that's populated only if a given header is present on the request. The descriptor key is static, and the descriptor value is equal to the value of the header.
 *
 * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeader
 */
export interface HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeader {
  /**
   * DescriptorKey defines the key to use on the descriptor entry.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeader#descriptorKey
   */
  readonly descriptorKey?: string;

  /**
   * HeaderName defines the name of the header to look for on the request.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeader#headerName
   */
  readonly headerName?: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeader(obj: HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'descriptorKey': obj.descriptorKey,
    'headerName': obj.headerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RequestHeaderValueMatch defines a descriptor entry that's populated if the request's headers match a set of 1+ match criteria. The descriptor key is "header_match", and the descriptor value is static.
 *
 * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch
 */
export interface HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch {
  /**
   * ExpectMatch defines whether the request must positively match the match criteria in order to generate a descriptor entry (i.e. true), or not match the match criteria in order to generate a descriptor entry (i.e. false). The default is true.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch#expectMatch
   */
  readonly expectMatch?: boolean;

  /**
   * Headers is a list of 1+ match criteria to apply against the request to determine whether to populate the descriptor entry or not.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch#headers
   */
  readonly headers?: HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders[];

  /**
   * Value defines the value of the descriptor entry.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch(obj: HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expectMatch': obj.expectMatch,
    'headers': obj.headers?.map(y => toJson_HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders(y)),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GenericKey defines a descriptor entry with a static key and value.
 *
 * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesGenericKey
 */
export interface HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesGenericKey {
  /**
   * Key defines the key of the descriptor entry. If not set, the key is set to "generic_key".
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesGenericKey#key
   */
  readonly key?: string;

  /**
   * Value defines the value of the descriptor entry.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesGenericKey#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesGenericKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesGenericKey(obj: HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesGenericKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RequestHeader defines a descriptor entry that's populated only if a given header is present on the request. The descriptor key is static, and the descriptor value is equal to the value of the header.
 *
 * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeader
 */
export interface HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeader {
  /**
   * DescriptorKey defines the key to use on the descriptor entry.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeader#descriptorKey
   */
  readonly descriptorKey?: string;

  /**
   * HeaderName defines the name of the header to look for on the request.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeader#headerName
   */
  readonly headerName?: string;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeader(obj: HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'descriptorKey': obj.descriptorKey,
    'headerName': obj.headerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RequestHeaderValueMatch defines a descriptor entry that's populated if the request's headers match a set of 1+ match criteria. The descriptor key is "header_match", and the descriptor value is static.
 *
 * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch
 */
export interface HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch {
  /**
   * ExpectMatch defines whether the request must positively match the match criteria in order to generate a descriptor entry (i.e. true), or not match the match criteria in order to generate a descriptor entry (i.e. false). The default is true.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch#expectMatch
   */
  readonly expectMatch?: boolean;

  /**
   * Headers is a list of 1+ match criteria to apply against the request to determine whether to populate the descriptor entry or not.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch#headers
   */
  readonly headers?: HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders[];

  /**
   * Value defines the value of the descriptor entry.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch(obj: HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expectMatch': obj.expectMatch,
    'headers': obj.headers?.map(y => toJson_HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders(y)),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HeaderMatchCondition specifies how to conditionally match against HTTP headers. The Name field is required, but only one of the remaining fields should be be provided.
 *
 * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders
 */
export interface HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders {
  /**
   * Contains specifies a substring that must be present in the header value.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders#contains
   */
  readonly contains?: string;

  /**
   * Exact specifies a string that the header value must be equal to.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders#exact
   */
  readonly exact?: string;

  /**
   * Name is the name of the header to match against. Name is required. Header names are case insensitive.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders#name
   */
  readonly name: string;

  /**
   * NotContains specifies a substring that must not be present in the header value.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders#notcontains
   */
  readonly notcontains?: string;

  /**
   * NoExact specifies a string that the header value must not be equal to. The condition is true if the header has any other value.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders#notexact
   */
  readonly notexact?: string;

  /**
   * NotPresent specifies that condition is true when the named header is not present. Note that setting NotPresent to false does not make the condition true if the named header is present.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders#notpresent
   */
  readonly notpresent?: boolean;

  /**
   * Present specifies that condition is true when the named header is present, regardless of its value. Note that setting Present to false does not make the condition true if the named header is absent.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders#present
   */
  readonly present?: boolean;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders(obj: HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contains': obj.contains,
    'exact': obj.exact,
    'name': obj.name,
    'notcontains': obj.notcontains,
    'notexact': obj.notexact,
    'notpresent': obj.notpresent,
    'present': obj.present,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HeaderMatchCondition specifies how to conditionally match against HTTP headers. The Name field is required, but only one of the remaining fields should be be provided.
 *
 * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders
 */
export interface HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders {
  /**
   * Contains specifies a substring that must be present in the header value.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders#contains
   */
  readonly contains?: string;

  /**
   * Exact specifies a string that the header value must be equal to.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders#exact
   */
  readonly exact?: string;

  /**
   * Name is the name of the header to match against. Name is required. Header names are case insensitive.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders#name
   */
  readonly name: string;

  /**
   * NotContains specifies a substring that must not be present in the header value.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders#notcontains
   */
  readonly notcontains?: string;

  /**
   * NoExact specifies a string that the header value must not be equal to. The condition is true if the header has any other value.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders#notexact
   */
  readonly notexact?: string;

  /**
   * NotPresent specifies that condition is true when the named header is not present. Note that setting NotPresent to false does not make the condition true if the named header is present.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders#notpresent
   */
  readonly notpresent?: boolean;

  /**
   * Present specifies that condition is true when the named header is present, regardless of its value. Note that setting Present to false does not make the condition true if the named header is absent.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders#present
   */
  readonly present?: boolean;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders(obj: HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contains': obj.contains,
    'exact': obj.exact,
    'name': obj.name,
    'notcontains': obj.notcontains,
    'notexact': obj.notexact,
    'notpresent': obj.notpresent,
    'present': obj.present,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * TLSCertificateDelegation is an TLS Certificate Delegation CRD specification. See design/tls-certificate-delegation.md for details.
 *
 * @schema TLSCertificateDelegation
 */
export class TlsCertificateDelegation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TLSCertificateDelegation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'projectcontour.io/v1',
    kind: 'TLSCertificateDelegation',
  }

  /**
   * Renders a Kubernetes manifest for "TLSCertificateDelegation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TlsCertificateDelegationProps): any {
    return {
      ...TlsCertificateDelegation.GVK,
      ...toJson_TlsCertificateDelegationProps(props),
    };
  }

  /**
   * Defines a "TLSCertificateDelegation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TlsCertificateDelegationProps) {
    super(scope, id, {
      ...TlsCertificateDelegation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TlsCertificateDelegation.GVK,
      ...toJson_TlsCertificateDelegationProps(resolved),
    };
  }
}

/**
 * TLSCertificateDelegation is an TLS Certificate Delegation CRD specification. See design/tls-certificate-delegation.md for details.
 *
 * @schema TLSCertificateDelegation
 */
export interface TlsCertificateDelegationProps {
  /**
   * @schema TLSCertificateDelegation#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * TLSCertificateDelegationSpec defines the spec of the CRD
   *
   * @schema TLSCertificateDelegation#spec
   */
  readonly spec: TlsCertificateDelegationSpec;

}

/**
 * Converts an object of type 'TlsCertificateDelegationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TlsCertificateDelegationProps(obj: TlsCertificateDelegationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TlsCertificateDelegationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLSCertificateDelegationSpec defines the spec of the CRD
 *
 * @schema TlsCertificateDelegationSpec
 */
export interface TlsCertificateDelegationSpec {
  /**
   * @schema TlsCertificateDelegationSpec#delegations
   */
  readonly delegations: TlsCertificateDelegationSpecDelegations[];

}

/**
 * Converts an object of type 'TlsCertificateDelegationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TlsCertificateDelegationSpec(obj: TlsCertificateDelegationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'delegations': obj.delegations?.map(y => toJson_TlsCertificateDelegationSpecDelegations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateDelegation maps the authority to reference a secret in the current namespace to a set of namespaces.
 *
 * @schema TlsCertificateDelegationSpecDelegations
 */
export interface TlsCertificateDelegationSpecDelegations {
  /**
   * required, the name of a secret in the current namespace.
   *
   * @schema TlsCertificateDelegationSpecDelegations#secretName
   */
  readonly secretName: string;

  /**
   * required, the namespaces the authority to reference the the secret will be delegated to. If TargetNamespaces is nil or empty, the CertificateDelegation' is ignored. If the TargetNamespace list contains the character, "*" the secret will be delegated to all namespaces.
   *
   * @schema TlsCertificateDelegationSpecDelegations#targetNamespaces
   */
  readonly targetNamespaces: string[];

}

/**
 * Converts an object of type 'TlsCertificateDelegationSpecDelegations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TlsCertificateDelegationSpecDelegations(obj: TlsCertificateDelegationSpecDelegations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretName': obj.secretName,
    'targetNamespaces': obj.targetNamespaces?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

